<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DJ Visualizer</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap');

    :root {
      --bg: #000;
      --ink: #fff;
      --ink-soft: rgba(255,255,255,0.6);
      --ink-faint: rgba(255,255,255,0.25);
      --ink-ultra: rgba(255,255,255,0.12);
      --panel: rgba(0,0,0,0.72);
      --border: rgba(255,255,255,0.14);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: var(--bg);
      color: var(--ink);
      font-family: 'Space Grotesk', 'Helvetica Neue', Arial, sans-serif;
      letter-spacing: 0.2px;
      overflow: hidden;
      height: 100vh;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      background: #000;
    }
    
    audio { display: none; }
    
    .controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: linear-gradient(transparent, rgba(0,0,0,0.86));
      padding: 28px 28px 22px;
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .controls.hidden {
      opacity: 0;
      transform: translateY(100%);
      pointer-events: none;
    }
    
    .viz-modes {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .viz-btn {
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      color: var(--ink);
      padding: 7px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .viz-btn:hover {
      background: rgba(255,255,255,0.12);
    }
    
    .viz-btn.active {
      background: rgba(255,255,255,0.2);
      border-color: rgba(255,255,255,0.35);
    }
    
    .viz-btn .key {
      display: inline-block;
      background: rgba(0,0,0,0.45);
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 10px;
      margin-right: 6px;
      font-family: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    
    .player-row {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .play-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .play-btn svg {
      fill: #fff;
      width: 20px;
      height: 20px;
    }
    
    .track-info {
      flex: 1;
      min-width: 0;
    }
    
    .track-name {
      font-size: 14px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .track-time {
      font-size: 11px;
      color: var(--ink-soft);
      margin-top: 3px;
    }
    
    .playlist-time {
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      margin-top: 2px;
    }
    
    .status-line {
      font-size: 11px;
      margin-top: 2px;
      color: var(--ink-soft);
    }
    
    .status-line[data-state="warn"] { color: rgba(255,255,255,0.85); }
    .status-line[data-state="error"] { color: rgba(255,255,255,0.95); }
    
    .progress-bar {
      flex: 2;
      height: 5px;
      background: rgba(255,255,255,0.12);
      border-radius: 999px;
      cursor: pointer;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: #fff;
      width: 0%;
      transition: width 0.1s linear;
    }
    
    .file-input { display: none; }
    
    .drop-zone {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 50;
      pointer-events: none;
    }
    
    .drop-zone.has-audio { display: none; }
    
    .drop-icon { font-size: 64px; margin-bottom: 20px; opacity: 0.25; }
    .drop-text { font-size: 22px; opacity: 0.65; }
    .drop-hint { font-size: 13px; opacity: 0.35; margin-top: 10px; }
    
    .top-actions {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      max-width: calc(100% - 40px);
      transition: opacity 0.3s;
    }
    
    .action-btn {
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      color: var(--ink);
      padding: 9px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
    }
    
    .action-btn:hover {
      background: rgba(255,255,255,0.15);
    }
    
    .top-actions.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .playlist {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      max-width: 300px;
      max-height: 50vh;
      overflow-y: auto;
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .playlist.hidden {
      opacity: 0;
      transform: translateX(-100%);
      pointer-events: none;
    }
    
    .playlist-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.5;
      margin-bottom: 10px;
    }
    
    .playlist-meta {
      font-size: 11px;
      opacity: 0.4;
      margin-top: -6px;
      margin-bottom: 10px;
    }
    
    .playlist-item {
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: background 0.2s;
    }
    
    .playlist-item:hover { background: rgba(255,255,255,0.1); }
    .playlist-item.active { background: rgba(255,255,255,0.16); }
    
    .playlist-item.disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    
    .mode-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(28px, 6vw, 48px);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      z-index: 150;
      text-shadow: none;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    .mode-display.show { opacity: 1; }
    
    .error-toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      border: 1px solid rgba(255,255,255,0.35);
      padding: 15px 25px;
      border-radius: 10px;
      z-index: 200;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    .error-toast.show { opacity: 1; }
    .error-toast.info { border-color: rgba(255,255,255,0.4); }
    .error-toast.warn { border-color: rgba(255,255,255,0.6); }
    
    .shortcuts-hint {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 11px;
      opacity: 0.3;
      z-index: 90;
      text-align: right;
      line-height: 1.6;
      transition: opacity 0.3s;
    }
    
    .shortcuts-hint.hidden { opacity: 0; }
    
    .start-overlay {
      position: fixed;
      inset: 0;
      z-index: 250;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
      background: radial-gradient(circle at center, rgba(20,20,20,0.35), rgba(0,0,0,0.95));
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }
    
    .start-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }
    
    .start-card {
      max-width: 640px;
      width: min(92vw, 640px);
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 22px;
      padding: 26px 28px;
      text-align: center;
      box-shadow: 0 40px 120px rgba(0,0,0,0.55);
    }
    
    .start-title {
      font-size: clamp(26px, 5vw, 34px);
      font-weight: 600;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }
    
    .start-subtitle {
      font-size: 15px;
      opacity: 0.75;
      line-height: 1.6;
      margin-bottom: 18px;
    }
    
    .start-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }
    
    .start-btn {
      font-size: 16px;
      padding: 12px 22px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.5);
      color: #fff;
      background: transparent;
      cursor: pointer;
      box-shadow: none;
    }
    
    .start-btn.secondary {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: none;
    }
    
    .start-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      box-shadow: none;
    }
    
    .start-note {
      font-size: 13px;
      opacity: 0.65;
      line-height: 1.6;
    }
    
    .diagnostics {
      text-align: left;
      margin-top: 14px;
      font-size: 12px;
      opacity: 0.85;
    }
    
    .diagnostics summary {
      cursor: pointer;
      margin-bottom: 6px;
    }
    
    .diagnostics pre {
      white-space: pre-wrap;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      font-family: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      line-height: 1.5;
    }
    
    .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 30px 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 200;
    }
    
    .help-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }
    
    .help-card {
      max-width: 860px;
      width: 100%;
      background: rgba(0,0,0,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 16px;
      padding: 24px 26px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.45);
    }
    
    .help-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 14px;
    }
    
    .help-title {
      font-size: 22px;
      font-weight: 600;
    }
    
    .help-close {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .help-columns {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
    }
    
    .help-column {
      flex: 1;
      min-width: 240px;
    }
    
    .help-section-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 8px;
    }
    
    .help-list {
      list-style: none;
      line-height: 1.8;
      font-size: 13px;
      opacity: 0.9;
    }
    
    .help-key {
      display: inline-block;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.2);
      padding: 2px 8px;
      border-radius: 6px;
      font-family: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      margin-right: 6px;
    }

    @media (max-width: 720px) {
      .controls {
        padding: 20px 18px 16px;
      }

      .player-row {
        flex-wrap: wrap;
        gap: 12px;
      }

      .progress-bar {
        flex-basis: 100%;
      }

      .top-actions {
        top: 12px;
        right: 12px;
        max-width: calc(100% - 24px);
      }

      .playlist {
        top: 12px;
        left: 12px;
        max-width: min(320px, 86vw);
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="drop-zone" id="dropZone">
    <div class="drop-icon">[]</div>
    <div class="drop-text">Drop audio files here</div>
    <div class="drop-hint">click anywhere or press O to choose a folder</div>
    <div class="drop-hint" style="margin-top: 15px;">AIFF playback works best in Safari.</div>
  </div>
  
  <audio id="audioEl" preload="auto" playsinline></audio>
  <div class="mode-display" id="modeDisplay"></div>
  <div class="error-toast" id="errorToast"></div>
  <div class="start-overlay show" id="startOverlay">
    <div class="start-card">
      <div class="start-title">DJ Visualizer</div>
      <div class="start-subtitle" id="startHint">Choose a folder, then hit Play to unlock audio.</div>
      <div class="start-actions">
        <button class="start-btn secondary" id="startFolderBtn">Choose Folder</button>
        <button class="start-btn" id="startPlayBtn" disabled>Play</button>
      </div>
      <details class="diagnostics" id="diagnosticsBox">
        <summary>Diagnostics</summary>
        <pre id="diagnosticsText">No diagnostics yet.</pre>
      </details>
    </div>
  </div>
  <div class="help-overlay" id="helpOverlay">
    <div class="help-card">
      <div class="help-header">
        <div class="help-title">Help / ヘルプ</div>
        <button class="help-close" id="helpClose">Close [Esc]</button>
      </div>
      <div class="help-columns">
        <div class="help-column">
          <div class="help-section-title">English</div>
          <ul class="help-list">
            <li><span class="help-key">O</span> Choose a music folder.</li>
            <li><span class="help-key">R</span> Rescan after adding files.</li>
            <li>Drag and drop files to add extra tracks.</li>
            <li>AIFF playback works best in Safari.</li>
            <li>Total playlist time + loop count show in the player.</li>
          </ul>
        </div>
        <div class="help-column">
          <div class="help-section-title">Shortcuts</div>
          <ul class="help-list">
            <li><span class="help-key">Space</span> Play / Pause</li>
            <li><span class="help-key">← / →</span> Previous / Next</li>
            <li><span class="help-key">1-9, 0</span> Visual modes</li>
            <li><span class="help-key">O</span> Folder picker</li>
            <li><span class="help-key">R</span> Rescan folder</li>
            <li><span class="help-key">H</span> Toggle help</li>
            <li><span class="help-key">F</span> Fullscreen</li>
          </ul>
        </div>
        <div class="help-column">
          <div class="help-section-title">日本語</div>
          <ul class="help-list">
            <li><span class="help-key">O</span> でフォルダを選択。</li>
            <li><span class="help-key">R</span> で再スキャン（曲追加後）。</li>
            <li>ドラッグ＆ドロップで曲を追加。</li>
            <li>AIFF は Safari 推奨。</li>
            <li>合計時間とループ回数が表示されます。</li>
          </ul>
        </div>
        <div class="help-column">
          <div class="help-section-title">ショートカット</div>
          <ul class="help-list">
            <li><span class="help-key">Space</span> 再生 / 停止</li>
            <li><span class="help-key">← / →</span> 前 / 次</li>
            <li><span class="help-key">1-9, 0</span> ビジュアル切替</li>
            <li><span class="help-key">O</span> フォルダ選択</li>
            <li><span class="help-key">R</span> 再スキャン</li>
            <li><span class="help-key">H</span> ヘルプ</li>
            <li><span class="help-key">F</span> フルスクリーン</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  
  <div class="playlist hidden" id="playlist">
    <div class="playlist-title">Playlist</div>
    <div class="playlist-meta" id="playlistMeta">Source: None</div>
    <div id="playlistItems"></div>
  </div>
  
  <div class="top-actions hidden" id="topActions">
    <button class="action-btn help-btn" id="helpBtn">Help [H]</button>
    <button class="action-btn folder-btn" id="folderBtn">Folder [O]</button>
    <button class="action-btn rescan-btn" id="rescanBtn">Rescan [R]</button>
    <button class="action-btn fullscreen-btn" id="fullscreenBtn">Fullscreen [F]</button>
  </div>
  
  <div class="shortcuts-hint hidden" id="shortcutsHint">
    1-9, 0 → visuals | O → folder | R → rescan | H → help | F → fullscreen<br>
    Space → play/pause | ←→ → tracks
  </div>
  
  <div class="controls hidden" id="controls">
    <div class="viz-modes" id="vizModes"></div>
    
    <div class="player-row">
      <button class="play-btn" id="playBtn">
        <svg viewBox="0 0 24 24" id="playIcon"><polygon points="5,3 19,12 5,21"/></svg>
      </button>
      <div class="track-info">
        <div class="track-name" id="trackName">No track loaded</div>
        <div class="track-time" id="trackTime">0:00 / 0:00</div>
        <div class="playlist-time" id="playlistTime">Playlist: --:-- · Loop: 0</div>
        <div class="status-line" id="statusLine" data-state="info">Waiting for audio…</div>
      </div>
      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
    </div>
  </div>
  
  <input type="file" class="file-input" id="fileInput" accept="audio/*" multiple>
  <input type="file" class="file-input" id="dirInput" webkitdirectory directory multiple>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const audioEl = document.getElementById('audioEl');
    
    let audioContext, analyser, source, audio;
    let analyserConnected = false;
    let dataArray, bufferLength, timeArray;
    let tracks = [];
    let currentTrackIndex = -1;
    let currentTrackId = null;
    let isPlaying = false;
    let hideTimeout;
    let fieldNodes = [];
    let burstSparks = [];
    let time = 0;
    let directoryHandle = null;
    let lastFolderLabel = '';
    let playlistLoopCount = 0;
    let totalPlaylistSeconds = 0;
    let durationScanId = 0;
    let loopAll = true;
    let lastStatus = '';
    const supportsDirectoryPicker = 'showDirectoryPicker' in window;
    const supportsDirInput = 'webkitdirectory' in document.createElement('input');
    const AUDIO_FILE_REGEX = /\.(mp3|wav|aiff|aif|flac|m4a|ogg|aac|alac|wma|opus)$/i;
    const HANDLE_DB_NAME = 'dj-visualizer';
    const HANDLE_DB_STORE = 'handles';
    const AUDIO_MIME_BY_EXT = {
      mp3: 'audio/mpeg',
      wav: 'audio/wav',
      aif: 'audio/aiff',
      aiff: 'audio/aiff',
      flac: 'audio/flac',
      m4a: 'audio/mp4',
      aac: 'audio/aac',
      ogg: 'audio/ogg',
      opus: 'audio/ogg',
      alac: 'audio/mp4',
      wma: 'audio/x-ms-wma'
    };
    
    function detectBrowser() {
      const ua = navigator.userAgent;
      const isEdge = /Edg/.test(ua);
      const isChrome = /Chrome|Chromium/.test(ua) && !isEdge;
      const isFirefox = /Firefox/.test(ua);
      const isSafari = /Safari/.test(ua) && !isChrome && !isEdge;
      let name = 'Browser';
      if (isSafari) name = 'Safari';
      else if (isChrome) name = 'Chrome';
      else if (isEdge) name = 'Edge';
      else if (isFirefox) name = 'Firefox';
      return { name, isSafari, isChrome, isEdge, isFirefox };
    }
    
    const browserInfo = detectBrowser();
    
    // ==================== VISUALIZATIONS ====================
    const visualizations = [
      { name: 'Lines', key: '1', fn: drawSpectrum },
      { name: 'Orbit', key: '2', fn: drawCircular },
      { name: 'Field', key: '3', fn: drawParticles },
      { name: 'Braid', key: '4', fn: drawDNA },
      { name: 'Arcs', key: '5', fn: drawKaleidoscope },
      { name: 'Spectrogram', key: '6', fn: drawSpectrogram },
      { name: 'Burst', key: '7', fn: drawFireworks },
      { name: 'Horizon', key: '8', fn: drawAurora },
      { name: 'Grid', key: '9', fn: drawSynthwave },
      { name: 'Nested', key: '0', fn: drawFractal },
    ];
    
    let currentVizIndex = 0;
    const SPECTROGRAM_BINS = 72;
    let spectrogramHistory = [];
    
    // ==================== HELPER FUNCTIONS ====================
    function isAudioFile(file) {
      return file && (file.type.startsWith('audio/') || AUDIO_FILE_REGEX.test(file.name));
    }
    
    function makeTrackId(file) {
      return `${file.name}::${file.size}::${file.lastModified}`;
    }
    
    function trackNameFromFile(file) {
      return file.name.replace(/\.[^.]+$/, '');
    }
    
    function makeTrackIdFromUrl(url) {
      return `url::${url}`;
    }
    
    function trackNameFromUrl(url) {
      try {
        const parsed = new URL(url, window.location.href);
        const pathname = parsed.pathname;
        const filename = pathname.split('/').pop() || 'Track';
        return decodeURIComponent(filename).replace(/\.[^.]+$/, '');
      } catch (err) {
        const fallback = url.split('/').pop() || 'Track';
        return fallback.replace(/\.[^.]+$/, '');
      }
    }
    
    function getExtension(input) {
      const match = /\\.([a-z0-9]+)$/i.exec(input || '');
      return match ? match[1].toLowerCase() : '';
    }
    
    function canPlayMime(mime) {
      if (!mime || !audioEl) return false;
      const result = audioEl.canPlayType(mime);
      return result === 'probably' || result === 'maybe';
    }
    
    function isSupportedFormat(ext, mime) {
      if (ext === 'aif' || ext === 'aiff') {
        return browserInfo.isSafari;
      }
      if (mime && canPlayMime(mime)) return true;
      if (ext && AUDIO_MIME_BY_EXT[ext]) {
        return canPlayMime(AUDIO_MIME_BY_EXT[ext]);
      }
      return false;
    }
    
    function unsupportedReason(ext) {
      if (ext === 'aif' || ext === 'aiff') {
        return `AIFF is not supported in ${browserInfo.name}. Use Safari or convert to WAV/MP3.`;
      }
      return `This format is not supported in ${browserInfo.name}.`;
    }
    
    function buildTrackFromFile(file) {
      const ext = getExtension(file.name);
      const mime = file.type || AUDIO_MIME_BY_EXT[ext] || '';
      const supported = isSupportedFormat(ext, mime);
      return {
        id: makeTrackId(file),
        name: trackNameFromFile(file),
        url: URL.createObjectURL(file),
        file,
        isObjectUrl: true,
        duration: NaN,
        extension: ext,
        mime,
        supported,
        unsupportedReason: supported ? '' : unsupportedReason(ext)
      };
    }
    
    function buildTrackFromUrl(url) {
      const ext = getExtension(url);
      const mime = AUDIO_MIME_BY_EXT[ext] || '';
      const supported = isSupportedFormat(ext, mime);
      return {
        id: makeTrackIdFromUrl(url),
        name: trackNameFromUrl(url),
        url,
        isObjectUrl: false,
        duration: NaN,
        extension: ext,
        mime,
        supported,
        unsupportedReason: supported ? '' : unsupportedReason(ext)
      };
    }
    
    function openHandleDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(HANDLE_DB_NAME, 1);
        request.onupgradeneeded = () => {
          request.result.createObjectStore(HANDLE_DB_STORE);
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    async function saveDirectoryHandle(handle) {
      try {
        const db = await openHandleDB();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(HANDLE_DB_STORE, 'readwrite');
          tx.objectStore(HANDLE_DB_STORE).put(handle, 'musicDir');
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (err) {
        console.warn('Could not store directory handle', err);
      }
    }
    
    async function loadDirectoryHandle() {
      try {
        const db = await openHandleDB();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(HANDLE_DB_STORE, 'readonly');
          const request = tx.objectStore(HANDLE_DB_STORE).get('musicDir');
          request.onsuccess = () => resolve(request.result || null);
          request.onerror = () => reject(request.error);
        });
      } catch (err) {
        console.warn('Could not load directory handle', err);
        return null;
      }
    }
    
    function setPlaylistMeta(text) {
      const meta = document.getElementById('playlistMeta');
      if (!meta) return;
      meta.textContent = text ? `Source: ${text}` : 'Source: None';
    }
    
    function syncCurrentTrackIndex() {
      if (!currentTrackId) {
        currentTrackIndex = tracks.length ? 0 : -1;
        return;
      }
      currentTrackIndex = tracks.findIndex(t => t.id === currentTrackId);
    }
    
    function formatDuration(totalSeconds) {
      if (!isFinite(totalSeconds)) return '--:--';
      const seconds = Math.max(0, Math.floor(totalSeconds));
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    function updatePlaylistStats() {
      const playlistTimeEl = document.getElementById('playlistTime');
      if (!playlistTimeEl) return;
      if (!tracks.length) {
        playlistLoopCount = 0;
        totalPlaylistSeconds = 0;
        playlistTimeEl.textContent = 'Playlist: --:-- · Loop: 0';
        return;
      }
      
      const durations = tracks.map(t => (isFinite(t.duration) ? t.duration : 0));
      const unknownCount = tracks.filter(t => !isFinite(t.duration)).length;
      const unsupportedCount = tracks.filter(t => !t.supported).length;
      totalPlaylistSeconds = durations.reduce((sum, val) => sum + val, 0);
      const totalLabel = formatDuration(totalPlaylistSeconds) + (unknownCount ? ' +' : '');
      const loopLabel = playlistLoopCount > 0 ? playlistLoopCount : 1;
      const unsupportedLabel = unsupportedCount ? ` · Unsupported: ${unsupportedCount}` : '';
      playlistTimeEl.textContent = `Playlist: ${totalLabel} · Loop: ${loopLabel}${unsupportedLabel}`;
    }
    
    function loadTrackDuration(track) {
      return new Promise(resolve => {
        if (!track || !track.url) return resolve();
        const probe = new Audio();
        probe.preload = 'metadata';
        probe.src = track.url;
        const cleanup = () => {
          probe.removeAttribute('src');
          probe.load();
        };
        probe.addEventListener('loadedmetadata', () => {
          track.duration = probe.duration;
          cleanup();
          resolve();
        }, { once: true });
        probe.addEventListener('error', () => {
          track.duration = 0;
          cleanup();
          resolve();
        }, { once: true });
      });
    }
    
    async function refreshPlaylistDurations() {
      if (!tracks.length) {
        updatePlaylistStats();
        return;
      }
      const scanId = ++durationScanId;
      updatePlaylistStats();
      for (const track of tracks) {
        if (scanId !== durationScanId) return;
        if (isFinite(track.duration)) continue;
        await loadTrackDuration(track);
        updatePlaylistStats();
      }
    }
    
    function getActiveVisualizations() {
      return visualizations;
    }
    
    function getAvgFrequency(start = 0, end = bufferLength) {
      let sum = 0;
      for (let i = start; i < end; i++) sum += dataArray[i];
      return sum / (end - start);
    }
    
    function getBass() { return getAvgFrequency(0, 10) || 0; }
    function getMid() { return getAvgFrequency(10, 100) || 0; }
    function getTreble() { return getAvgFrequency(100, bufferLength) || 0; }
    
    function getRmsLevel() {
      if (!timeArray || !timeArray.length) return 0;
      let sum = 0;
      for (let i = 0; i < timeArray.length; i++) {
        const v = (timeArray[i] - 128) / 128;
        sum += v * v;
      }
      return Math.sqrt(sum / timeArray.length);
    }
    
    function getFreqIndexForHz(freq, nyquist) {
      if (!bufferLength) return 0;
      const clamped = Math.max(0, Math.min(nyquist, freq));
      return Math.min(bufferLength - 1, Math.max(0, Math.round((clamped / nyquist) * (bufferLength - 1))));
    }
    
    function getAvgFrequencyByHz(minHz, maxHz, nyquist) {
      if (!dataArray || !bufferLength) return 0;
      const start = getFreqIndexForHz(minHz, nyquist);
      const end = Math.max(start + 1, getFreqIndexForHz(maxHz, nyquist));
      let sum = 0;
      for (let i = start; i <= end; i++) sum += dataArray[i];
      return sum / Math.max(1, end - start + 1);
    }
    
    // Safe radius for canvas arc (prevents IndexSizeError)
    function safeRadius(r) { return Math.max(0.1, r) || 0.1; }

    function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

    function lerp(a, b, t) { return a + (b - a) * t; }

    function clearCanvas(w, h, alpha = 1) {
      ctx.fillStyle = alpha >= 1 ? '#000' : `rgba(0,0,0,${alpha})`;
      ctx.fillRect(0, 0, w, h);
    }
    
    // ==================== SPECTRUM BARS ====================
    function drawSpectrum() {
      analyser.getByteFrequencyData(dataArray);
      analyser.getByteTimeDomainData(timeArray);
      const w = window.innerWidth, h = window.innerHeight;
      clearCanvas(w, h, 1);
      
      const bars = Math.max(36, Math.floor(w / 18));
      const barW = w / bars;
      const nyquist = (audioContext ? audioContext.sampleRate : 48000) / 2;
      const minFreq = 30;
      const maxFreq = Math.min(16000, nyquist);
      const midY = h * 0.62;
      const rms = getRmsLevel();
      
      ctx.lineWidth = 1;
      ctx.lineCap = 'round';
      ctx.strokeStyle = '#fff';
      
      for (let i = 0; i < bars; i++) {
        if (i % 2 === 1) continue;
        const t = i / (bars - 1);
        const freq = minFreq * Math.pow(maxFreq / minFreq, t);
        const idx = getFreqIndexForHz(freq, nyquist);
        const val = dataArray[idx] / 255;
        const height = Math.pow(val, 1.6) * Math.min(w, h) * 0.45;
        const x = i * barW + barW * 0.5;
        
        ctx.globalAlpha = 0.08 + val * 0.9;
        ctx.beginPath();
        ctx.moveTo(x, midY - height * 0.6);
        ctx.lineTo(x, midY + height * 0.4);
        ctx.stroke();
      }
      
      ctx.globalAlpha = 0.15 + rms * 0.5;
      ctx.beginPath();
      ctx.moveTo(w * 0.08, midY);
      ctx.lineTo(w * 0.92, midY);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // ==================== CIRCULAR ====================
    function drawCircular() {
      analyser.getByteFrequencyData(dataArray);
      analyser.getByteTimeDomainData(timeArray);
      const w = window.innerWidth, h = window.innerHeight;
      const cx = w / 2, cy = h / 2;
      const minDim = Math.min(w, h);
      
      clearCanvas(w, h, 0.12);
      
      time += 0.01;
      const nyquist = (audioContext ? audioContext.sampleRate : 48000) / 2;
      const rings = 6;
      ctx.lineWidth = 1;
      ctx.lineCap = 'round';
      ctx.strokeStyle = '#fff';
      
      for (let i = 0; i < rings; i++) {
        const band = getAvgFrequencyByHz(40 + i * 200, 200 + i * 700, nyquist) / 255;
        const radius = minDim * (0.12 + i * 0.07) * (1 + band * 0.45);
        ctx.setLineDash([minDim * 0.01, minDim * 0.02]);
        ctx.globalAlpha = 0.12 + band * 0.7;
        ctx.beginPath();
        ctx.arc(cx, cy, safeRadius(radius), 0, Math.PI * 2);
        ctx.stroke();
      }
      
      ctx.setLineDash([]);
      
      const spokes = 48;
      const spin = time * 0.8;
      const inner = minDim * 0.14;
      const outer = minDim * 0.42;
      for (let i = 0; i < spokes; i++) {
        const idx = Math.floor(i * bufferLength / spokes);
        const val = dataArray[idx] / 255;
        const angle = (i / spokes) * Math.PI * 2 + spin;
        const r2 = inner + (outer - inner) * (0.2 + val * 0.8);
        ctx.globalAlpha = 0.05 + val * 0.6;
        ctx.beginPath();
        ctx.moveTo(cx + Math.cos(angle) * inner, cy + Math.sin(angle) * inner);
        ctx.lineTo(cx + Math.cos(angle) * r2, cy + Math.sin(angle) * r2);
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1;
    }
    
    // ==================== PARTICLES ====================
    function drawParticles() {
      analyser.getByteFrequencyData(dataArray);
      analyser.getByteTimeDomainData(timeArray);
      const w = window.innerWidth, h = window.innerHeight;
      clearCanvas(w, h, 0.14);
      time += 0.008;
      
      const targetCount = clamp(Math.floor((w * h) / 6800), 90, 210);
      if (fieldNodes.length !== targetCount) {
        fieldNodes = Array.from({ length: targetCount }, () => ({
          x: Math.random() * w,
          y: Math.random() * h,
          vx: 0,
          vy: 0,
          px: 0,
          py: 0
        }));
        for (const node of fieldNodes) {
          node.px = node.x;
          node.py = node.y;
        }
      }
      
      const rms = getRmsLevel();
      const speedBase = 0.55 + rms * 2.2;
      const swirl = 1.1 + (getBass() / 255) * 1.6;
      const step = Math.max(1, Math.floor(bufferLength / fieldNodes.length));
      
      ctx.strokeStyle = '#fff';
      ctx.lineCap = 'round';
      ctx.lineWidth = 1;
      for (let i = 0; i < fieldNodes.length; i++) {
        const node = fieldNodes[i];
        const audio = dataArray[Math.min(bufferLength - 1, i * step)] / 255;
        const nx = node.x / w - 0.5;
        const ny = node.y / h - 0.5;
        const angle =
          Math.sin((ny * 10) + time * 1.8) * 1.1 +
          Math.cos((nx * 9) - time * 1.2) * 0.9 +
          Math.atan2(ny, nx) * 0.4 * swirl;
        
        const targetVx = Math.cos(angle) * (speedBase + audio * 1.8);
        const targetVy = Math.sin(angle) * (speedBase + audio * 1.8);
        node.vx = lerp(node.vx, targetVx, 0.12);
        node.vy = lerp(node.vy, targetVy, 0.12);
        
        node.px = node.x;
        node.py = node.y;
        node.x += node.vx;
        node.y += node.vy;
        
        if (node.x < -20) node.x = w + 20;
        if (node.x > w + 20) node.x = -20;
        if (node.y < -20) node.y = h + 20;
        if (node.y > h + 20) node.y = -20;
        
        ctx.globalAlpha = 0.05 + audio * 0.5;
        ctx.beginPath();
        ctx.moveTo(node.px, node.py);
        ctx.lineTo(node.x, node.y);
        ctx.stroke();
      }
      
      const focusRadius = Math.min(w, h) * 0.2;
      for (let i = 0; i < 4; i++) {
        const pulse = (Math.sin(time * 2.2 + i) + 1) * 0.5;
        ctx.globalAlpha = 0.05 + pulse * 0.1 + rms * 0.2;
        ctx.beginPath();
        ctx.arc(w * 0.5, h * 0.5, focusRadius * (0.65 + i * 0.22 + pulse * 0.08), 0, Math.PI * 2);
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1;
    }
    
    // ==================== DNA HELIX ====================
    function drawDNA() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      analyser.getByteTimeDomainData(timeArray);
      clearCanvas(w, h, 0.12);
      
      time += 0.02;
      const nyquist = (audioContext ? audioContext.sampleRate : 48000) / 2;
      const bass = getAvgFrequencyByHz(30, 160, nyquist) / 255;
      const strands = 50;
      const amplitude = Math.min(w, h) * (0.18 + bass * 0.2);
      
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      ctx.fillStyle = '#fff';
      
      for (let i = 0; i < strands; i++) {
        const progress = i / (strands - 1);
        const idx = Math.floor(progress * bufferLength);
        const val = dataArray[idx] / 255;
        const y = progress * h;
        
        const phase = time + progress * 8;
        const x1 = w / 2 + Math.sin(phase) * amplitude;
        const x2 = w / 2 + Math.sin(phase + Math.PI) * amplitude;
        
        ctx.globalAlpha = 0.08 + val * 0.65;
        ctx.beginPath();
        ctx.moveTo(x1, y);
        ctx.lineTo(x2, y);
        ctx.stroke();
        
        const dot = 1 + val * 2.5;
        ctx.globalAlpha = 0.1 + val * 0.7;
        ctx.beginPath();
        ctx.arc(x1, y, safeRadius(dot), 0, Math.PI * 2);
        ctx.arc(x2, y, safeRadius(dot), 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.globalAlpha = 1;
    }
    
    // ==================== KALEIDOSCOPE ====================
    function drawKaleidoscope() {
      analyser.getByteFrequencyData(dataArray);
      analyser.getByteTimeDomainData(timeArray);
      const w = window.innerWidth, h = window.innerHeight;
      const cx = w / 2, cy = h / 2;
      
      clearCanvas(w, h, 0.1);
      time += 0.012;
      
      const minDim = Math.min(w, h);
      const layers = 8;
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      ctx.lineCap = 'round';
      
      for (let i = 0; i < layers; i++) {
        const idx = Math.floor((i / layers) * bufferLength);
        const val = dataArray[idx] / 255;
        const r = minDim * (0.12 + i * 0.07) + val * minDim * 0.08;
        const swing = Math.sin(time + i * 0.4) * 0.08;
        ctx.globalAlpha = 0.08 + val * 0.7;
        ctx.beginPath();
        ctx.arc(cx, cy + minDim * 0.08, safeRadius(r), Math.PI * (1.05 + swing), Math.PI * (1.95 - swing));
        ctx.stroke();
      }
      
      const rms = getRmsLevel();
      const travel = Math.sin(time * 2.2) * minDim * 0.04 + (rms - 0.25) * minDim * 0.12;
      const lineX = cx + travel;
      const lineTop = cy - minDim * 0.36;
      const lineBottom = cy + minDim * 0.36;
      const markerY = lerp(lineBottom, lineTop, clamp(rms * 1.5, 0, 1));
      
      ctx.globalAlpha = 0.16 + rms * 0.45;
      ctx.beginPath();
      ctx.moveTo(lineX, lineTop);
      ctx.lineTo(lineX, lineBottom);
      ctx.stroke();
      
      ctx.globalAlpha = 0.45 + rms * 0.4;
      ctx.beginPath();
      ctx.arc(lineX, markerY, safeRadius(2 + rms * 7), 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    // ==================== SPECTROGRAM ====================
    function drawSpectrogram() {
      analyser.getByteFrequencyData(dataArray);
      analyser.getByteTimeDomainData(timeArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      clearCanvas(w, h, 0.26);
      
      const nyquist = (audioContext ? audioContext.sampleRate : 48000) / 2;
      const minFreq = 28;
      const maxFreq = Math.min(17000, nyquist);
      const row = new Float32Array(SPECTROGRAM_BINS);
      for (let i = 0; i < SPECTROGRAM_BINS; i++) {
        const t = i / (SPECTROGRAM_BINS - 1);
        const freq = minFreq * Math.pow(maxFreq / minFreq, t);
        const idx = getFreqIndexForHz(freq, nyquist);
        row[i] = Math.pow(dataArray[idx] / 255, 1.25);
      }
      
      spectrogramHistory.unshift(row);
      const rowHeight = 3;
      const maxRows = Math.floor((h * 0.96) / (rowHeight * 2));
      if (spectrogramHistory.length > maxRows) spectrogramHistory.length = maxRows;
      
      const bandW = w / SPECTROGRAM_BINS;
      const centerY = h * 0.5;
      for (let r = 0; r < spectrogramHistory.length; r++) {
        const fade = 1 - r / maxRows;
        const yTop = centerY - r * rowHeight;
        const yBottom = centerY + r * rowHeight;
        const energy = spectrogramHistory[r];
        
        for (let i = 0; i < SPECTROGRAM_BINS; i++) {
          const val = energy[i];
          if (val < 0.02) continue;
          const alpha = Math.pow(val, 0.9) * fade * 0.95;
          ctx.globalAlpha = alpha;
          const x = i * bandW;
          const width = Math.max(1, bandW - 1);
          ctx.fillStyle = '#fff';
          ctx.fillRect(x, yBottom, width, rowHeight - 1);
          ctx.fillRect(x, yTop - rowHeight + 1, width, rowHeight - 1);
        }
      }
      
      const rms = getRmsLevel();
      const markerW = w * (0.06 + rms * 0.16);
      ctx.globalAlpha = 0.2 + rms * 0.4;
      ctx.fillStyle = '#fff';
      ctx.fillRect((w - markerW) * 0.5, centerY - 1, markerW, 2);
      
      ctx.globalAlpha = 0.08 + rms * 0.3;
      ctx.beginPath();
      ctx.moveTo(w * 0.08, centerY);
      ctx.lineTo(w * 0.92, centerY);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    // ==================== FIREWORKS ====================
    let fireworks = [];
    function drawFireworks() {
      analyser.getByteFrequencyData(dataArray);
      analyser.getByteTimeDomainData(timeArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      clearCanvas(w, h, 0.18);
      time += 0.013;
      const bass = getBass() / 255;
      const rms = getRmsLevel();
      const minDim = Math.min(w, h);
      const shouldLaunch = (bass > 0.62 && Math.random() > 0.45) || Math.random() > 0.992;
      
      if (shouldLaunch && fireworks.length < 8) {
        fireworks.push({
          x: w * 0.5 + (Math.random() - 0.5) * minDim * 0.42,
          y: h * 0.5 + (Math.random() - 0.5) * minDim * 0.26,
          life: 1,
          lines: 22 + Math.floor(Math.random() * 24),
          radius: minDim * (0.05 + Math.random() * 0.06),
          spin: Math.random() * Math.PI * 2,
          driftX: (Math.random() - 0.5) * 0.7,
          driftY: (Math.random() - 0.5) * 0.6
        });
        
        const sparks = 20 + Math.floor(Math.random() * 26);
        for (let i = 0; i < sparks; i++) {
          const angle = (i / sparks) * Math.PI * 2 + Math.random() * 0.4;
          const speed = 0.8 + Math.random() * (1.6 + bass * 2.8);
          burstSparks.push({
            x: fireworks[fireworks.length - 1].x,
            y: fireworks[fireworks.length - 1].y,
            px: fireworks[fireworks.length - 1].x,
            py: fireworks[fireworks.length - 1].y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1
          });
        }
      }
      
      const nextBursts = [];
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.2;
      
      for (let i = 0; i < fireworks.length; i++) {
        const burst = fireworks[i];
        const energy = getMid() / 255;
        burst.x += burst.driftX;
        burst.y += burst.driftY;
        const growth = 1.4 - burst.life;
        const radius = burst.radius * (0.7 + growth * 2.2 + energy * 0.4);
        
        for (let j = 0; j < burst.lines; j++) {
          const angle = (j / burst.lines) * Math.PI * 2 + burst.spin + time * 0.8;
          const inner = radius * (0.18 + 0.22 * Math.sin(time * 3 + j));
          const outer = radius * (0.85 + 0.25 * Math.sin(time * 2 + j * 0.3));
          ctx.globalAlpha = burst.life * (0.06 + energy * 0.88);
          ctx.beginPath();
          ctx.moveTo(
            burst.x + Math.cos(angle) * inner,
            burst.y + Math.sin(angle) * inner
          );
          ctx.lineTo(
            burst.x + Math.cos(angle) * outer,
            burst.y + Math.sin(angle) * outer
          );
          ctx.stroke();
        }
        
        for (let ring = 0; ring < 3; ring++) {
          ctx.globalAlpha = burst.life * (0.09 + ring * 0.07);
          ctx.beginPath();
          ctx.arc(
            burst.x,
            burst.y,
            safeRadius(radius * (0.45 + ring * 0.23) + Math.sin(time * 4 + ring) * 3),
            0,
            Math.PI * 2
          );
          ctx.stroke();
        }
        
        burst.life -= 0.018 + energy * 0.01;
        if (burst.life > 0) nextBursts.push(burst);
      }
      
      fireworks = nextBursts;
      
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      burstSparks = burstSparks.filter(spark => spark.life > 0.02);
      for (const spark of burstSparks) {
        spark.px = spark.x;
        spark.py = spark.y;
        spark.x += spark.vx;
        spark.y += spark.vy;
        spark.vx *= 0.985;
        spark.vy *= 0.985;
        spark.life -= 0.024;
        
        ctx.globalAlpha = spark.life * 0.45;
        ctx.beginPath();
        ctx.moveTo(spark.px, spark.py);
        ctx.lineTo(spark.x, spark.y);
        ctx.stroke();
      }
      
      ctx.globalAlpha = 0.18 + rms * 0.5;
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.5, safeRadius(minDim * (0.14 + rms * 0.06)), 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    // ==================== AURORA ====================
    function drawAurora() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      analyser.getByteTimeDomainData(timeArray);
      clearCanvas(w, h, 0.1);
      time += 0.012;
      
      const rms = getRmsLevel();
      const centerX = w * 0.5;
      const span = w * 0.8;
      const startX = centerX - span * 0.5;
      const endX = centerX + span * 0.5;
      const baseY = h * 0.43;
      const amp = h * 0.14;
      const layers = 7;
      const points = Math.max(120, Math.floor(span / 7));
      
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      for (let layer = 0; layer < layers; layer++) {
        const yBase = baseY + layer * (h * 0.065);
        ctx.beginPath();
        for (let i = 0; i <= points; i++) {
          const t = i / points;
          const x = lerp(startX, endX, t);
          const idx = Math.floor(t * (bufferLength - 1));
          const audio = (dataArray[idx] / 255 - 0.5) * amp;
          const envelope = Math.sin(Math.PI * t);
          const wave =
            Math.sin(time * 2 + t * 9 + layer * 0.35) * amp * 0.22 +
            Math.sin(time * 1.4 + t * 15 + layer) * amp * 0.08;
          const y = yBase - (wave + audio * 0.58) * envelope;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.globalAlpha = 0.06 + layer * 0.04 + rms * 0.4;
        ctx.stroke();
      }
      
      const crownY = baseY - amp * 0.56;
      const pulse = clamp(rms * 1.7, 0, 1);
      const windowW = span * (0.18 + pulse * 0.25);
      const offset = Math.sin(time * 1.8) * span * 0.12;
      ctx.globalAlpha = 0.16 + pulse * 0.5;
      ctx.beginPath();
      ctx.moveTo(startX, crownY);
      ctx.lineTo(endX, crownY);
      ctx.stroke();
      
      ctx.globalAlpha = 0.42 + pulse * 0.4;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(centerX - windowW * 0.5 + offset, crownY);
      ctx.lineTo(centerX + windowW * 0.5 + offset, crownY);
      ctx.stroke();
      
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.12 + pulse * 0.4;
      ctx.beginPath();
      ctx.arc(centerX, baseY + amp * 0.95, safeRadius(span * (0.12 + pulse * 0.04)), 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    // ==================== SYNTHWAVE ====================
    function drawSynthwave() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      analyser.getByteTimeDomainData(timeArray);
      clearCanvas(w, h, 0.95);
      
      time += 0.013;
      const bass = getBass() / 255;
      const rms = getRmsLevel();
      const horizon = h * 0.56 + bass * h * 0.028;
      const cols = 18;
      const rows = 18;
      const sweep = (time * 70) % (h - horizon);
      
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#fff';
      for (let i = -cols; i <= cols; i++) {
        const t = i / cols;
        const xTop = w * 0.5 + t * w * 0.16;
        const xBottom = w * 0.5 + t * w * 0.72;
        const bend = Math.sin(time * 1.8 + t * 2.5) * w * 0.01 * (0.2 + bass);
        const falloff = 1 - Math.abs(t);
        ctx.globalAlpha = 0.05 + falloff * 0.5;
        ctx.beginPath();
        ctx.moveTo(xTop + bend, horizon);
        ctx.lineTo(xBottom + bend * 2.6, h);
        ctx.stroke();
      }
      
      for (let r = 0; r <= rows; r++) {
        const t = r / rows;
        const y = horizon + Math.pow(t, 2.08) * (h - horizon);
        const idx = Math.floor(t * (bufferLength - 1));
        const val = dataArray[idx] / 255;
        ctx.globalAlpha = 0.05 + val * 0.54;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
      
      const frameW = Math.min(w, h) * 0.38 * (1 + rms * 0.08);
      const frameH = frameW * (0.5 + bass * 0.08);
      const frameY = horizon - frameH * 0.92;
      ctx.globalAlpha = 0.14 + rms * 0.66;
      ctx.strokeRect(w * 0.5 - frameW * 0.5, frameY, frameW, frameH);
      
      const wavePts = Math.max(80, Math.floor(w / 9));
      ctx.globalAlpha = 0.12 + rms * 0.65;
      ctx.beginPath();
      for (let i = 0; i <= wavePts; i++) {
        const t = i / wavePts;
        const x = t * w;
        const idx = Math.floor(t * (bufferLength - 1));
        const val = dataArray[idx] / 255 - 0.5;
        const y = horizon - 12 + Math.sin(time * 3 + t * 10) * 5 - val * (h * 0.07);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      
      ctx.globalAlpha = 0.09 + rms * 0.35;
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, horizon + sweep, w, 1.4);
      
      ctx.globalAlpha = 1;
    }
    
    // ==================== FRACTAL ====================
    function drawFractal() {
      analyser.getByteFrequencyData(dataArray);
      analyser.getByteTimeDomainData(timeArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      clearCanvas(w, h, 0.16);
      time += 0.014;
      
      const minDim = Math.min(w, h);
      const rms = getRmsLevel();
      const layers = 14;
      const spokes = 12;
      const centerX = w * 0.5;
      const centerY = h * 0.5;
      
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      for (let i = 0; i < layers; i++) {
        const t = i / (layers - 1);
        const idx = Math.floor(t * (bufferLength - 1));
        const val = dataArray[idx] / 255;
        const size = minDim * (0.18 + t * 0.48) * (0.9 + rms * 0.2);
        const rot = time * (0.2 + t * 0.8) * (i % 2 === 0 ? 1 : -1);
        ctx.save();
        ctx.rotate(rot);
        ctx.globalAlpha = 0.04 + val * 0.6;
        ctx.strokeRect(-size * 0.5, -size * 0.5, size, size);
        ctx.restore();
      }
      
      for (let i = 0; i < spokes; i++) {
        const t = i / spokes;
        const idx = Math.floor(t * (bufferLength - 1));
        const val = dataArray[idx] / 255;
        const angle = t * Math.PI * 2 + time * 0.5;
        const r1 = minDim * 0.09;
        const r2 = minDim * (0.3 + val * 0.23);
        ctx.globalAlpha = 0.05 + val * 0.55;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * r1, Math.sin(angle) * r1);
        ctx.lineTo(Math.cos(angle) * r2, Math.sin(angle) * r2);
        ctx.stroke();
        
        ctx.globalAlpha = 0.12 + val * 0.45;
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * r2, Math.sin(angle) * r2, safeRadius(1.2 + val * 4.2), 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }
      
      ctx.restore();
      ctx.globalAlpha = 1;
    }
    
    // ==================== UI SETUP ====================
    function resize() {
      const ratio = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * ratio;
      canvas.height = window.innerHeight * ratio;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(ratio, ratio);
    }
    window.addEventListener('resize', resize);
    resize();
    
    // Build viz buttons
    const vizModes = document.getElementById('vizModes');
    function renderVizButtons() {
      vizModes.innerHTML = '';
      const list = getActiveVisualizations();
      list.forEach((viz, i) => {
        const btn = document.createElement('button');
        btn.className = 'viz-btn' + (i === 0 ? ' active' : '');
        btn.innerHTML = `<span class="key">${viz.key}</span>${viz.name}`;
        btn.dataset.index = i;
        btn.onclick = () => setVisualization(i);
        vizModes.appendChild(btn);
      });
    }
    renderVizButtons();
    
    function setVisualization(index) {
      const list = getActiveVisualizations();
      const safeIndex = Math.max(0, Math.min(index, list.length - 1));
      currentVizIndex = safeIndex;
      document.querySelectorAll('.viz-btn').forEach((b, i) => {
        b.classList.toggle('active', i === safeIndex);
      });
      showModeDisplay(list[safeIndex].name);
      // Reset mode-specific state
      fieldNodes = [];
      fireworks = [];
      burstSparks = [];
      spectrogramHistory = [];
      // Reset canvas state
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function showModeDisplay(text, color = '#fff') {
      const display = document.getElementById('modeDisplay');
      display.textContent = text;
      display.style.color = color;
      display.classList.add('show');
      setTimeout(() => display.classList.remove('show'), 800);
    }
    
    function toggleHelp(show = null) {
      const overlay = document.getElementById('helpOverlay');
      if (!overlay) return;
      if (show === null) {
        overlay.classList.toggle('show');
      } else {
        overlay.classList.toggle('show', show);
      }
    }
    
    function setStatus(msg, type = 'info') {
      if (!msg || msg === lastStatus) return;
      lastStatus = msg;
      const line = document.getElementById('statusLine');
      if (!line) return;
      line.textContent = msg;
      line.dataset.state = type;
    }
    
    function showStartOverlay(show) {
      const overlay = document.getElementById('startOverlay');
      if (!overlay) return;
      overlay.classList.toggle('show', !!show);
    }
    
    function updateStartOverlay() {
      const hint = document.getElementById('startHint');
      const playBtn = document.getElementById('startPlayBtn');
      const folderBtn = document.getElementById('startFolderBtn');
      if (!hint) return;
      if (!tracks.length) {
        hint.textContent = 'Choose a folder, then hit Play to unlock audio.';
        if (playBtn) playBtn.disabled = true;
        if (folderBtn) folderBtn.textContent = 'Choose Folder';
      } else {
        hint.textContent = 'Click Play to unlock audio and start.';
        if (playBtn) playBtn.disabled = false;
        if (folderBtn) folderBtn.textContent = 'Change Folder';
      }
    }
    
    function readyStateLabel(state) {
      return {
        0: 'HAVE_NOTHING',
        1: 'HAVE_METADATA',
        2: 'HAVE_CURRENT_DATA',
        3: 'HAVE_FUTURE_DATA',
        4: 'HAVE_ENOUGH_DATA'
      }[state] || `UNKNOWN(${state})`;
    }
    
    function networkStateLabel(state) {
      return {
        0: 'NETWORK_EMPTY',
        1: 'NETWORK_IDLE',
        2: 'NETWORK_LOADING',
        3: 'NETWORK_NO_SOURCE'
      }[state] || `UNKNOWN(${state})`;
    }
    
    function updateDiagnostics(reason = 'status') {
      const box = document.getElementById('diagnosticsText');
      if (!box) return;
      const track = tracks[currentTrackIndex];
      const audioState = audio ? {
        src: audio.src,
        paused: audio.paused,
        muted: audio.muted,
        ended: audio.ended,
        volume: audio.volume,
        currentTime: audio.currentTime,
        duration: audio.duration,
        readyState: readyStateLabel(audio.readyState),
        networkState: networkStateLabel(audio.networkState),
        error: audio.error ? audio.error.code : 'none'
      } : null;
      const contextState = audioContext ? audioContext.state : 'none';
      const sampleRate = audioContext ? audioContext.sampleRate : '-';
      const diagnostics = [
        `Reason: ${reason}`,
        `Protocol: ${window.location.protocol}`,
        `Browser: ${browserInfo.name}`,
        `User Agent: ${navigator.userAgent}`,
        `Context: ${contextState} (${sampleRate} Hz)`,
        `Track: ${track ? track.name : 'none'}`,
        `Track Extension: ${track ? track.extension : 'n/a'}`,
        `Tracks Loaded: ${tracks.length}`,
        `Audio: ${audioState ? 'present' : 'none'}`,
        audioState ? `Audio Src: ${audioState.src}` : null,
        audioState ? `Audio Paused: ${audioState.paused}` : null,
        audioState ? `Audio Muted: ${audioState.muted}` : null,
        audioState ? `Audio Ended: ${audioState.ended}` : null,
        audioState ? `Audio Volume: ${audioState.volume}` : null,
        audioState ? `Audio Time: ${audioState.currentTime.toFixed(2)} / ${isFinite(audioState.duration) ? audioState.duration.toFixed(2) : 'NaN'}` : null,
        audioState ? `Ready State: ${audioState.readyState}` : null,
        audioState ? `Network State: ${audioState.networkState}` : null,
        audioState ? `Audio Error: ${audioState.error}` : null
      ].filter(Boolean).join('\n');
      box.textContent = diagnostics;
    }
    
    // ==================== AUDIO ====================
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.3;
        analyser.minDecibels = -90;
        analyser.maxDecibels = -10;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        timeArray = new Uint8Array(bufferLength);
        analyserConnected = false;
      }
      if (!source) {
        source = audioContext.createMediaElementSource(audioEl);
        source.connect(analyser);
      }
      if (!analyserConnected) {
        analyser.connect(audioContext.destination);
        analyserConnected = true;
      }
    }
    
    function showToast(msg, type = 'error') {
      const toast = document.getElementById('errorToast');
      toast.textContent = msg;
      toast.classList.remove('info', 'warn');
      if (type === 'info') toast.classList.add('info');
      if (type === 'warn') toast.classList.add('warn');
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 5000);
    }
    
    function showError(msg) {
      showToast(msg, 'error');
      setStatus(msg, 'error');
      updateDiagnostics('error');
    }
    
    function showInfo(msg) {
      showToast(msg, 'info');
      setStatus(msg, 'info');
      updateDiagnostics('info');
    }
    
    function showWarn(msg) {
      showToast(msg, 'warn');
      setStatus(msg, 'warn');
      updateDiagnostics('warn');
    }
    
    function describeAudioError(track, error) {
      const code = error ? error.code : null;
      const ext = track && track.extension ? track.extension : '';
      const base = track ? `"${track.name}"` : 'This track';
      switch (code) {
        case 1:
          return `${base} playback was aborted.`;
        case 2:
          return `${base} could not be loaded (network or file error).`;
        case 3:
          return `${base} could not be decoded. Try Safari for AIFF or convert to WAV/MP3.`;
        case 4:
          return `${base} is not supported in this browser.`;
        default:
          if (ext === 'aif' || ext === 'aiff') {
            return `${base} is AIFF. Use Safari or convert to WAV/MP3.`;
          }
          return `${base} could not be played.`;
      }
    }
    
    function findNextSupportedIndex(startIndex, direction = 1) {
      if (!tracks.length) return -1;
      let idx = startIndex;
      for (let i = 0; i < tracks.length; i++) {
        if (idx >= tracks.length) idx = 0;
        if (idx < 0) idx = tracks.length - 1;
        if (tracks[idx] && tracks[idx].supported) return idx;
        idx += direction;
      }
      return -1;
    }
    
    function loadTrack(index, options = {}) {
      if (tracks.length === 0) return;
      
      const track = tracks[index];
      if (!track) return false;
      
      if (!track.supported) {
        showWarn(track.unsupportedReason || 'This track format is not supported.');
        if (options.allowSkip === false) {
          updateDiagnostics('unsupported track');
          return false;
        }
        const nextIdx = findNextSupportedIndex(index + 1, 1);
        if (nextIdx === -1) {
          showError(`No playable tracks in ${browserInfo.name}.`);
          updateDiagnostics('no playable tracks');
          return false;
        }
        return loadTrack(nextIdx, options);
      }
      
      currentTrackIndex = index;
      currentTrackId = track.id;
      updateDiagnostics('load track');
      
      audio = audioEl;
      if (audio) {
        audio.pause();
      }
      
      audio.src = track.url;
      audio.load();
      
      showInfo(`Loading: ${track.name}`);
      audio.onerror = () => {
        showError(describeAudioError(track, audio.error));
        showStartOverlay(true);
        updateDiagnostics('audio error');
      };
      audio.oncanplay = () => {
        showInfo(`Ready: ${track.name}`);
        updateDiagnostics('canplay');
      };
      audio.onplaying = () => {
        setStatus(`Playing: ${track.name}`, 'info');
        showStartOverlay(false);
        showControls();
        updateDiagnostics('playing');
      };
      audio.onpause = () => {
        if (!audio.ended) setStatus(`Paused: ${track.name}`, 'info');
        updateDiagnostics('pause');
      };
      audio.onwaiting = () => {
        setStatus(`Buffering: ${track.name}`, 'warn');
        updateDiagnostics('waiting');
      };
      audio.onstalled = () => {
        setStatus(`Stalled: ${track.name}`, 'warn');
        updateDiagnostics('stalled');
      };
      audio.onplay = () => {
        setStatus(`Play requested: ${track.name}`, 'info');
        updateDiagnostics('play event');
      };
      audio.onended = () => {
        setStatus(`Ended: ${track.name}`, 'info');
        updateDiagnostics('ended');
      };
      
      initAudio();
      
      document.getElementById('trackName').textContent = track.name;
      document.getElementById('dropZone').classList.add('has-audio');
      
      audio.addEventListener('timeupdate', updateProgress);
      audio.addEventListener('ended', () => {
        if (!tracks.length) {
          pause();
          return;
        }
        playNextTrack({ auto: true });
      });
      
      updatePlaylist();
      return true;
    }
    
    function updatePlayIcon(playing) {
      document.getElementById('playIcon').innerHTML = playing
        ? '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>'
        : '<polygon points="5,3 19,12 5,21"/>';
    }
    
    function play() {
      if (!audio) {
        showWarn('No track loaded. Choose a folder first.');
        showStartOverlay(true);
        return;
      }
      initAudio();
      const resumePromise = audioContext.resume();
      if (resumePromise && resumePromise.catch) {
        resumePromise.catch(() => {
          showWarn('Audio context is blocked. Click the page to enable sound.');
          showStartOverlay(true);
        });
      }
      
      const playPromise = audio.play();
      const startTime = audio.currentTime;
      setTimeout(() => {
        if (audio && audio.paused && audio.currentTime === startTime) {
          showWarn('Playback did not start. Click Play again or reload the page.');
          showStartOverlay(true);
          updateDiagnostics('play watchdog');
        }
      }, 900);
      if (playPromise && playPromise.then) {
        playPromise.then(() => {
          isPlaying = true;
          updatePlayIcon(true);
          showStartOverlay(false);
          updateDiagnostics('play success');
        }).catch(err => {
          isPlaying = false;
          updatePlayIcon(false);
          if (err && err.name === 'NotAllowedError') {
            showWarn('Playback blocked. Click anywhere or press Space to start.');
            showStartOverlay(true);
          } else if (err && err.name === 'NotSupportedError') {
            showError('Playback failed: format not supported.');
            showStartOverlay(true);
          } else {
            showError('Playback failed. Try another track or browser.');
            showStartOverlay(true);
          }
          updateDiagnostics('play failed');
        });
      } else {
        isPlaying = true;
        updatePlayIcon(true);
        showStartOverlay(false);
        updateDiagnostics('play fallback');
      }
    }
    
    function pause() {
      if (!audio) return;
      audio.pause();
      isPlaying = false;
      updatePlayIcon(false);
    }
    
    function playNextTrack(options = {}) {
      if (!tracks.length) return;
      const auto = options.auto === true;
      const nextIndex = currentTrackIndex === -1 ? 0 : currentTrackIndex + 1;
      if (nextIndex < tracks.length) {
        const loaded = loadTrack(nextIndex);
        if (loaded) play();
        return;
      }
      if (loopAll) {
        playlistLoopCount = Math.max(1, playlistLoopCount);
        if (auto) playlistLoopCount += 1;
        const loaded = loadTrack(0);
        if (loaded) play();
        updatePlaylistStats();
      } else {
        pause();
      }
    }
    
    function playPreviousTrack() {
      if (!tracks.length) return;
      const prevIndex = currentTrackIndex === -1 ? 0 : currentTrackIndex - 1;
      if (prevIndex >= 0) {
        const loaded = loadTrack(prevIndex);
        if (loaded) play();
        return;
      }
      if (loopAll) {
        const loaded = loadTrack(tracks.length - 1);
        if (loaded) play();
      }
    }
    
    function updateProgress() {
      if (!audio) return;
      const duration = audio.duration;
      const progress = duration && isFinite(duration) ? (audio.currentTime / duration) * 100 : 0;
      document.getElementById('progressFill').style.width = progress + '%';
      document.getElementById('trackTime').textContent = 
        formatTime(audio.currentTime) + ' / ' + formatTime(duration);
    }
    
    function formatTime(s) {
      if (isNaN(s)) return '0:00';
      return Math.floor(s / 60) + ':' + Math.floor(s % 60).toString().padStart(2, '0');
    }
    
    function updatePlaylist() {
      const container = document.getElementById('playlistItems');
      container.innerHTML = '';
      tracks.forEach((track, i) => {
        const item = document.createElement('div');
        const isActive = i === currentTrackIndex;
        const isDisabled = !track.supported;
        item.className = 'playlist-item' + (isActive ? ' active' : '') + (isDisabled ? ' disabled' : '');
        item.textContent = track.name + (isDisabled ? ' (unsupported)' : '');
        item.onclick = () => {
          const loaded = loadTrack(i, { allowSkip: false });
          if (loaded) play();
        };
        container.appendChild(item);
      });
      updatePlaylistStats();
    }
    
    function appendTracksFromFiles(files, sourceLabel = 'Files') {
      const audioFiles = Array.from(files).filter(isAudioFile);
      if (audioFiles.length === 0) {
        showWarn('No audio files found.');
        return;
      }
      
      const existingIds = new Set(tracks.map(t => t.id));
      audioFiles.forEach(file => {
        const track = buildTrackFromFile(file);
        if (existingIds.has(track.id)) return;
        tracks.push(track);
        existingIds.add(track.id);
      });
      
      if (tracks.length > 0) {
        document.getElementById('playlist').classList.remove('hidden');
        syncCurrentTrackIndex();
        updatePlaylist();
        if (!audio) loadTrack(0);
      }
      updateStartOverlay();
      const unsupportedCount = tracks.filter(t => !t.supported).length;
      const supportNote = unsupportedCount ? ` (${unsupportedCount} unsupported in ${browserInfo.name})` : '';
      showInfo(`Added ${audioFiles.length} track${audioFiles.length === 1 ? '' : 's'}.${supportNote}`);
      
      if (playlistLoopCount === 0 && tracks.length) {
        playlistLoopCount = 1;
      }
      refreshPlaylistDurations();
      
      const metaLabel = lastFolderLabel ? `${lastFolderLabel} + ${sourceLabel}` : sourceLabel;
      setPlaylistMeta(metaLabel);
    }
    
    function replaceTracksFromFiles(files, sourceLabel = 'Folder') {
      const audioFiles = Array.from(files).filter(isAudioFile);
      if (audioFiles.length === 0) {
        showWarn('No audio files found in this folder.');
        return;
      }
      
      audioFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
      const oldById = new Map(tracks.map(t => [t.id, t]));
      const nextTracks = [];
      
      audioFiles.forEach(file => {
        const id = makeTrackId(file);
        const existing = oldById.get(id);
        if (existing) {
          existing.file = file;
          nextTracks.push(existing);
        } else {
          nextTracks.push(buildTrackFromFile(file));
        }
      });
      
      const nextIds = new Set(nextTracks.map(t => t.id));
      tracks.forEach(t => {
        if (!nextIds.has(t.id) && t.isObjectUrl) URL.revokeObjectURL(t.url);
      });
      
      const wasPlaying = isPlaying;
      tracks = nextTracks;
      syncCurrentTrackIndex();
      document.getElementById('playlist').classList.remove('hidden');
      updatePlaylist();
      if (!audio && tracks.length) {
        loadTrack(0);
      } else if (wasPlaying && currentTrackIndex === -1 && tracks.length) {
        const loaded = loadTrack(0);
        if (loaded) play();
      }
      updateStartOverlay();
      if (tracks.length) {
        playlistLoopCount = 1;
      } else {
        playlistLoopCount = 0;
      }
      refreshPlaylistDurations();
      
      lastFolderLabel = sourceLabel;
      setPlaylistMeta(sourceLabel);
      const unsupportedCount = tracks.filter(t => !t.supported).length;
      const supportNote = unsupportedCount ? ` (${unsupportedCount} unsupported in ${browserInfo.name})` : '';
      showInfo(`Loaded ${tracks.length} track${tracks.length === 1 ? '' : 's'} from ${sourceLabel}.${supportNote}`);
    }
    
    function replaceTracksFromUrls(urls, sourceLabel = 'Current Folder') {
      if (!urls || urls.length === 0) {
        showWarn('No audio files found in this folder.');
        return false;
      }
      
      const unique = Array.from(new Set(urls));
      const oldById = new Map(tracks.map(t => [t.id, t]));
      const nextTracks = unique.map(url => {
        const id = makeTrackIdFromUrl(url);
        const existing = oldById.get(id);
        if (existing) return existing;
        return buildTrackFromUrl(url);
      });
      
      const nextIds = new Set(nextTracks.map(t => t.id));
      tracks.forEach(t => {
        if (!nextIds.has(t.id) && t.isObjectUrl) URL.revokeObjectURL(t.url);
      });
      
      const wasPlaying = isPlaying;
      tracks = nextTracks;
      syncCurrentTrackIndex();
      document.getElementById('playlist').classList.remove('hidden');
      updatePlaylist();
      
      if (!audio && tracks.length) {
        loadTrack(0);
      } else if (wasPlaying && currentTrackIndex === -1 && tracks.length) {
        const loaded = loadTrack(0);
        if (loaded) play();
      }
      
      if (tracks.length) {
        playlistLoopCount = 1;
      } else {
        playlistLoopCount = 0;
      }
      refreshPlaylistDurations();
      
      lastFolderLabel = sourceLabel;
      setPlaylistMeta(sourceLabel);
      const unsupportedCount = tracks.filter(t => !t.supported).length;
      const supportNote = unsupportedCount ? ` (${unsupportedCount} unsupported in ${browserInfo.name})` : '';
      showInfo(`Loaded ${tracks.length} track${tracks.length === 1 ? '' : 's'} from ${sourceLabel}.${supportNote}`);
      return true;
    }
    
    function getFolderLabelFromFiles(files) {
      const first = files && files[0];
      if (!first || !first.webkitRelativePath) return 'Folder';
      const parts = first.webkitRelativePath.split('/');
      return parts[0] || 'Folder';
    }
    
    function getCurrentFolderLabel() {
      const path = decodeURIComponent(window.location.pathname || '');
      const parts = path.split('/').filter(Boolean);
      if (parts.length === 0) return 'Current Folder';
      const last = parts[parts.length - 1];
      if (last.includes('.')) {
        return parts[parts.length - 2] || 'Current Folder';
      }
      return last || 'Current Folder';
    }
    
    function extractAudioUrlsFromListing(html, baseUrl) {
      const links = new Set();
      const hrefRegex = /href\s*=\s*["']([^"']+)["']/gi;
      let match;
      while ((match = hrefRegex.exec(html))) {
        const href = match[1];
        if (!href || href.startsWith('?') || href.startsWith('#')) continue;
        if (href.toLowerCase().startsWith('javascript:')) continue;
        let url;
        try {
          url = new URL(href, baseUrl);
        } catch (err) {
          continue;
        }
        if (url.pathname.endsWith('/')) continue;
        if (!AUDIO_FILE_REGEX.test(url.pathname)) continue;
        links.add(url.href);
      }
      return Array.from(links);
    }
    
    async function autoDetectFromDirectoryListing() {
      if (window.location.protocol === 'file:') {
        return false;
      }
      const baseUrl = window.location.href.replace(/[#?].*$/, '');
      try {
        const response = await fetch('./', { cache: 'no-store' });
        if (!response.ok) return false;
        const text = await response.text();
        const urls = extractAudioUrlsFromListing(text, baseUrl);
        if (!urls.length) return false;
        const label = getCurrentFolderLabel();
        return replaceTracksFromUrls(urls, label);
      } catch (err) {
        return false;
      }
    }
    
    async function scanDirectoryHandle(handle) {
      const files = [];
      for await (const [name, entry] of handle.entries()) {
        if (entry.kind !== 'file') continue;
        if (!AUDIO_FILE_REGEX.test(name)) continue;
        const file = await entry.getFile();
        files.push(file);
      }
      
      if (files.length === 0) {
        showWarn('No audio files found in this folder.');
        return;
      }
      
      replaceTracksFromFiles(files, handle.name || 'Folder');
    }
    
    async function chooseFolder() {
      if (supportsDirectoryPicker) {
        try {
          const handle = await window.showDirectoryPicker({ mode: 'read' });
          directoryHandle = handle;
          await saveDirectoryHandle(handle);
          await scanDirectoryHandle(handle);
        } catch (err) {
          if (err && err.name !== 'AbortError') {
            showError('Could not access that folder.');
          }
        }
      } else if (supportsDirInput) {
        document.getElementById('dirInput').click();
      } else {
        document.getElementById('fileInput').click();
        showError('Folder picking not supported in this browser. Select files instead.');
      }
    }
    
    async function rescanLibrary() {
      if (directoryHandle) {
        try {
          const perm = await directoryHandle.queryPermission({ mode: 'read' });
          if (perm !== 'granted') {
            const req = await directoryHandle.requestPermission({ mode: 'read' });
            if (req !== 'granted') {
              showError('Folder permission not granted.');
              return;
            }
          }
          await scanDirectoryHandle(directoryHandle);
        } catch (err) {
          showError('Could not rescan the folder.');
        }
        return;
      }
      
      const autoFound = await autoDetectFromDirectoryListing();
      if (!autoFound) {
        await chooseFolder();
      }
    }
    
    // ==================== EVENT HANDLERS ====================
    document.body.addEventListener('dragover', e => e.preventDefault());
    document.body.addEventListener('drop', e => {
      e.preventDefault();
      appendTracksFromFiles(e.dataTransfer.files, 'Dropped Files');
    });
    
    document.body.addEventListener('click', e => {
      if (!tracks.length && (e.target === document.body || e.target === canvas || 
          e.target.closest('.drop-zone'))) {
        chooseFolder();
      }
    });
    
    document.getElementById('fileInput').addEventListener('change', e => {
      appendTracksFromFiles(e.target.files, 'Files');
      e.target.value = '';
    });
    
    document.getElementById('dirInput').addEventListener('change', e => {
      const label = getFolderLabelFromFiles(e.target.files);
      const files = Array.from(e.target.files);
      const topLevelFiles = files.filter(file => {
        const rel = file.webkitRelativePath || '';
        const depth = rel.split('/').filter(Boolean).length;
        return depth <= 2;
      });
      if (topLevelFiles.length !== files.length) {
        showInfo('Ignoring subfolders. Only top-level files are loaded.');
      }
      replaceTracksFromFiles(topLevelFiles, label);
      e.target.value = '';
    });
    
    document.getElementById('playBtn').onclick = () => isPlaying ? pause() : play();
    document.getElementById('folderBtn').onclick = () => chooseFolder();
    document.getElementById('rescanBtn').onclick = () => rescanLibrary();
    document.getElementById('helpBtn').onclick = () => toggleHelp();
    document.getElementById('helpClose').onclick = () => toggleHelp(false);
    document.getElementById('helpOverlay').addEventListener('click', e => {
      if (e.target.id === 'helpOverlay') toggleHelp(false);
    });
    document.getElementById('startFolderBtn').onclick = async () => {
      await chooseFolder();
      updateStartOverlay();
    };
    document.getElementById('startPlayBtn').onclick = () => {
      if (!tracks.length) {
        showWarn('Choose a folder first.');
        return;
      }
      if (!audio && tracks.length) {
        const loaded = loadTrack(0);
        if (!loaded) return;
      }
      play();
    };
    
    document.getElementById('progressBar').onclick = e => {
      if (!audio || !isFinite(audio.duration)) return;
      const rect = e.currentTarget.getBoundingClientRect();
      audio.currentTime = ((e.clientX - rect.left) / rect.width) * audio.duration;
    };
    
    document.getElementById('fullscreenBtn').onclick = () => {
      document.fullscreenElement ? document.exitFullscreen() : document.body.requestFullscreen();
    };
    
    // Auto-hide controls
    function showControls() {
      if (document.getElementById('startOverlay').classList.contains('show')) return;
      document.getElementById('controls').classList.remove('hidden');
      document.getElementById('topActions').classList.remove('hidden');
      document.getElementById('playlist').classList.remove('hidden');
      document.getElementById('shortcutsHint').classList.remove('hidden');
      clearTimeout(hideTimeout);
      hideTimeout = setTimeout(() => {
        if (isPlaying) {
          document.getElementById('controls').classList.add('hidden');
          document.getElementById('topActions').classList.add('hidden');
          document.getElementById('playlist').classList.add('hidden');
          document.getElementById('shortcutsHint').classList.add('hidden');
        }
      }, 3000);
    }
    
    document.addEventListener('mousemove', showControls);
    
    // ==================== KEYBOARD SHORTCUTS ====================
    document.addEventListener('keydown', e => {
      // Number keys for visualizations
      const vizKey = visualizations.findIndex(v => v.key === e.key);
      if (vizKey !== -1) {
        setVisualization(vizKey);
        return;
      }
      
      switch(e.code) {
        case 'Space':
          e.preventDefault();
          isPlaying ? pause() : play();
          break;
        case 'ArrowRight':
          playNextTrack();
          break;
        case 'ArrowLeft':
          playPreviousTrack();
          break;
        case 'KeyF':
          document.getElementById('fullscreenBtn').click();
          break;
        case 'KeyO':
          chooseFolder();
          break;
        case 'KeyR':
          rescanLibrary();
          break;
        case 'KeyH':
          toggleHelp();
          break;
        case 'Escape':
          toggleHelp(false);
          break;
      }
    });
    
    // ==================== AUTO-LOAD SAVED FOLDER ====================
    async function autoLoadSavedFolder() {
      let loaded = false;
      if (supportsDirectoryPicker) {
        const handle = await loadDirectoryHandle();
        if (handle) {
          const perm = await handle.queryPermission({ mode: 'read' });
          if (perm === 'granted') {
            directoryHandle = handle;
            await scanDirectoryHandle(handle);
            loaded = true;
          }
        }
      }
      if (!loaded) {
        await autoDetectFromDirectoryListing();
      }
    }
    
    updateStartOverlay();
    updateDiagnostics('init');
    autoLoadSavedFolder();
    
    // ==================== ANIMATION LOOP ====================
    function animate() {
      try {
        if (analyser && dataArray) {
          const list = getActiveVisualizations();
          if (list[currentVizIndex]) list[currentVizIndex].fn();
        } else {
          // Clear to black when no audio
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        }
      } catch (err) {
        console.error('Visualization error:', err);
        // Reset canvas state to prevent corruption
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
      requestAnimationFrame(animate);
    }
    
    animate();
  </script>
</body>
</html>

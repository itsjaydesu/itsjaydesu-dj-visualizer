<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DJ Visualizer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
      overflow: hidden;
      height: 100vh;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    .controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: linear-gradient(transparent, rgba(0,0,0,0.95));
      padding: 30px 30px 25px;
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .controls.hidden {
      opacity: 0;
      transform: translateY(100%);
      pointer-events: none;
    }
    
    .viz-modes {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .viz-btn {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      color: #fff;
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .viz-btn:hover {
      background: rgba(255,255,255,0.15);
    }
    
    .viz-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: transparent;
    }
    
    .viz-btn .key {
      display: inline-block;
      background: rgba(0,0,0,0.3);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      margin-right: 6px;
      font-family: monospace;
    }
    
    .player-row {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .play-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .play-btn svg {
      fill: #fff;
      width: 20px;
      height: 20px;
    }
    
    .track-info {
      flex: 1;
      min-width: 0;
    }
    
    .track-name {
      font-size: 14px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .track-time {
      font-size: 11px;
      color: rgba(255,255,255,0.5);
      margin-top: 3px;
    }
    
    .playlist-time {
      font-size: 11px;
      color: rgba(255,255,255,0.45);
      margin-top: 2px;
    }
    
    .progress-bar {
      flex: 2;
      height: 6px;
      background: rgba(255,255,255,0.1);
      border-radius: 3px;
      cursor: pointer;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      width: 0%;
      transition: width 0.1s linear;
    }
    
    .file-input { display: none; }
    
    .drop-zone {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 50;
      pointer-events: none;
    }
    
    .drop-zone.has-audio { display: none; }
    
    .drop-icon { font-size: 80px; margin-bottom: 20px; opacity: 0.3; }
    .drop-text { font-size: 24px; opacity: 0.5; }
    .drop-hint { font-size: 14px; opacity: 0.3; margin-top: 10px; }
    
    .top-actions {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      max-width: calc(100% - 40px);
      transition: opacity 0.3s;
    }
    
    .action-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    
    .action-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .top-actions.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .playlist {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0,0,0,0.85);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 15px;
      max-width: 300px;
      max-height: 50vh;
      overflow-y: auto;
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .playlist.hidden {
      opacity: 0;
      transform: translateX(-100%);
      pointer-events: none;
    }
    
    .playlist-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.5;
      margin-bottom: 10px;
    }
    
    .playlist-meta {
      font-size: 11px;
      opacity: 0.4;
      margin-top: -6px;
      margin-bottom: 10px;
    }
    
    .playlist-item {
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: background 0.2s;
    }
    
    .playlist-item:hover { background: rgba(255,255,255,0.1); }
    .playlist-item.active {
      background: linear-gradient(135deg, rgba(102,126,234,0.3), rgba(118,75,162,0.3));
    }
    
    .mode-display {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 4px;
      opacity: 0;
      z-index: 150;
      text-shadow: 0 0 40px currentColor;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    .mode-display.show { opacity: 1; }
    
    .error-toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(220, 38, 38, 0.92);
      padding: 15px 25px;
      border-radius: 10px;
      z-index: 200;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    .error-toast.show { opacity: 1; }
    .error-toast.info { background: rgba(59, 130, 246, 0.92); }
    .error-toast.warn { background: rgba(234, 179, 8, 0.92); }
    
    .shortcuts-hint {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 11px;
      opacity: 0.3;
      z-index: 90;
      text-align: right;
      line-height: 1.6;
      transition: opacity 0.3s;
    }
    
    .shortcuts-hint.hidden { opacity: 0; }
    
    .help-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 30px 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 200;
    }
    
    .help-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }
    
    .help-card {
      max-width: 860px;
      width: 100%;
      background: rgba(10,10,10,0.95);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 24px 26px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.45);
    }
    
    .help-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 14px;
    }
    
    .help-title {
      font-size: 24px;
      font-weight: 600;
    }
    
    .help-close {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .help-columns {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
    }
    
    .help-column {
      flex: 1;
      min-width: 240px;
    }
    
    .help-section-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 8px;
    }
    
    .help-list {
      list-style: none;
      line-height: 1.8;
      font-size: 13px;
      opacity: 0.9;
    }
    
    .help-key {
      display: inline-block;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.2);
      padding: 2px 8px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      margin-right: 6px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="drop-zone" id="dropZone">
    <div class="drop-icon">üéµ</div>
    <div class="drop-text">Drop audio files here</div>
    <div class="drop-hint">click anywhere or press O to choose a folder</div>
    <div class="drop-hint" style="margin-top: 15px; color: #f5af19;">‚ö†Ô∏è AIFF files require Safari</div>
  </div>
  
  <div class="mode-display" id="modeDisplay"></div>
  <div class="error-toast" id="errorToast"></div>
  <div class="help-overlay" id="helpOverlay">
    <div class="help-card">
      <div class="help-header">
        <div class="help-title">Help / „Éò„É´„Éó</div>
        <button class="help-close" id="helpClose">Close [Esc]</button>
      </div>
      <div class="help-columns">
        <div class="help-column">
          <div class="help-section-title">English</div>
          <ul class="help-list">
            <li><span class="help-key">O</span> Choose a music folder.</li>
            <li><span class="help-key">R</span> Rescan after adding files.</li>
            <li>Drag and drop files to add extra tracks.</li>
            <li>AIFF playback works best in Safari.</li>
            <li>Total playlist time + loop count show in the player.</li>
          </ul>
        </div>
        <div class="help-column">
          <div class="help-section-title">Shortcuts</div>
          <ul class="help-list">
            <li><span class="help-key">Space</span> Play / Pause</li>
            <li><span class="help-key">‚Üê / ‚Üí</span> Previous / Next</li>
            <li><span class="help-key">1-9, 0</span> Visual modes</li>
            <li><span class="help-key">C</span> Color scheme</li>
            <li><span class="help-key">O</span> Folder picker</li>
            <li><span class="help-key">R</span> Rescan folder</li>
            <li><span class="help-key">H</span> Toggle help</li>
            <li><span class="help-key">F</span> Fullscreen</li>
          </ul>
        </div>
        <div class="help-column">
          <div class="help-section-title">Êó•Êú¨Ë™û</div>
          <ul class="help-list">
            <li><span class="help-key">O</span> „Åß„Éï„Ç©„É´„ÉÄ„ÇíÈÅ∏Êäû„ÄÇ</li>
            <li><span class="help-key">R</span> „ÅßÂÜç„Çπ„Ç≠„É£„É≥ÔºàÊõ≤ËøΩÂä†ÂæåÔºâ„ÄÇ</li>
            <li>„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó„ÅßÊõ≤„ÇíËøΩÂä†„ÄÇ</li>
            <li>AIFF „ÅØ Safari Êé®Â•®„ÄÇ</li>
            <li>ÂêàË®àÊôÇÈñì„Å®„É´„Éº„ÉóÂõûÊï∞„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</li>
          </ul>
        </div>
        <div class="help-column">
          <div class="help-section-title">„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà</div>
          <ul class="help-list">
            <li><span class="help-key">Space</span> ÂÜçÁîü / ÂÅúÊ≠¢</li>
            <li><span class="help-key">‚Üê / ‚Üí</span> Ââç / Ê¨°</li>
            <li><span class="help-key">1-9, 0</span> „Éì„Ç∏„É•„Ç¢„É´ÂàáÊõø</li>
            <li><span class="help-key">C</span> „Ç´„É©„Éº„Çπ„Ç≠„Éº„É†</li>
            <li><span class="help-key">O</span> „Éï„Ç©„É´„ÉÄÈÅ∏Êäû</li>
            <li><span class="help-key">R</span> ÂÜç„Çπ„Ç≠„É£„É≥</li>
            <li><span class="help-key">H</span> „Éò„É´„Éó</li>
            <li><span class="help-key">F</span> „Éï„É´„Çπ„ÇØ„É™„Éº„É≥</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  
  <div class="playlist hidden" id="playlist">
    <div class="playlist-title">Playlist</div>
    <div class="playlist-meta" id="playlistMeta">Source: None</div>
    <div id="playlistItems"></div>
  </div>
  
  <div class="top-actions" id="topActions">
    <button class="action-btn help-btn" id="helpBtn">? Help [H]</button>
    <button class="action-btn folder-btn" id="folderBtn">üìÅ Folder [O]</button>
    <button class="action-btn rescan-btn" id="rescanBtn">‚Üª Rescan [R]</button>
    <button class="action-btn color-btn-main" id="colorBtn">üé® <span id="colorName">Neon</span> [C]</button>
    <button class="action-btn fullscreen-btn" id="fullscreenBtn">‚õ∂ Fullscreen [F]</button>
  </div>
  
  <div class="shortcuts-hint" id="shortcutsHint">
    1-9, 0 ‚Üí visuals | C ‚Üí colors | O ‚Üí folder | R ‚Üí rescan | H ‚Üí help | F ‚Üí fullscreen<br>
    Space ‚Üí play/pause | ‚Üê‚Üí ‚Üí tracks
  </div>
  
  <div class="controls" id="controls">
    <div class="viz-modes" id="vizModes"></div>
    
    <div class="player-row">
      <button class="play-btn" id="playBtn">
        <svg viewBox="0 0 24 24" id="playIcon"><polygon points="5,3 19,12 5,21"/></svg>
      </button>
      <div class="track-info">
        <div class="track-name" id="trackName">No track loaded</div>
        <div class="track-time" id="trackTime">0:00 / 0:00</div>
        <div class="playlist-time" id="playlistTime">Playlist: --:-- ¬∑ Loop: 0</div>
      </div>
      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
    </div>
  </div>
  
  <input type="file" class="file-input" id="fileInput" accept="audio/*" multiple>
  <input type="file" class="file-input" id="dirInput" webkitdirectory directory multiple>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let audioContext, analyser, source, audio;
    let analyserConnected = false;
    let dataArray, bufferLength, timeArray;
    let tracks = [];
    let currentTrackIndex = -1;
    let currentTrackId = null;
    let isPlaying = false;
    let hideTimeout;
    let particles = [];
    let time = 0;
    let directoryHandle = null;
    let lastFolderLabel = '';
    let playlistLoopCount = 0;
    let totalPlaylistSeconds = 0;
    let durationScanId = 0;
    let loopAll = true;
    const supportsDirectoryPicker = 'showDirectoryPicker' in window;
    const supportsDirInput = 'webkitdirectory' in document.createElement('input');
    const AUDIO_FILE_REGEX = /\.(mp3|wav|aiff|aif|flac|m4a|ogg|aac|alac|wma|opus)$/i;
    const HANDLE_DB_NAME = 'dj-visualizer';
    const HANDLE_DB_STORE = 'handles';
    
    // ==================== VISUALIZATIONS ====================
    const visualizations = [
      { name: 'Spectrum', key: '1', fn: drawSpectrum },
      { name: 'Circular', key: '2', fn: drawCircular },
      { name: 'Particles', key: '3', fn: drawParticles },
      { name: 'DNA Helix', key: '4', fn: drawDNA },
      { name: 'Kaleidoscope', key: '5', fn: drawKaleidoscope },
      { name: 'Matrix', key: '6', fn: drawMatrix },
      { name: 'Fireworks', key: '7', fn: drawFireworks },
      { name: 'Aurora', key: '8', fn: drawAurora },
      { name: 'Synthwave', key: '9', fn: drawSynthwave },
      { name: 'Fractal', key: '0', fn: drawFractal },
    ];
    
    let currentVizIndex = 0;
    
    // ==================== COLOR SCHEMES ====================
    const colorSchemes = [
      { name: 'Rainbow', colors: ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'] },
      { name: 'Neon', colors: ['#ff00ff', '#00ffff', '#ff00aa', '#00ff88', '#ffff00'] },
      { name: 'Sunset', colors: ['#ff6b6b', '#feca57', '#ff9ff3', '#f368e0', '#ff9f43'] },
      { name: 'Ocean', colors: ['#0077b6', '#00b4d8', '#90e0ef', '#48cae4', '#023e8a'] },
      { name: 'Fire', colors: ['#ff0000', '#ff4500', '#ff8c00', '#ffd700', '#ffff00'] },
      { name: 'Matrix', colors: ['#00ff00', '#00dd00', '#00bb00', '#009900', '#003300'] },
      { name: 'Vapor', colors: ['#ff71ce', '#01cdfe', '#05ffa1', '#b967ff', '#fffb96'] },
      { name: 'Ice', colors: ['#a8edea', '#fed6e3', '#d299c2', '#fef9d7', '#89f7fe'] },
      { name: 'Lava', colors: ['#f12711', '#f5af19', '#c31432', '#240b36', '#ff416c'] },
      { name: 'Galaxy', colors: ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe'] },
      { name: 'Toxic', colors: ['#00ff87', '#60efff', '#ff00ea', '#ffc800', '#00ffc8'] },
    ];
    
    let currentColorIndex = 0;
    
    // ==================== HELPER FUNCTIONS ====================
    function isAudioFile(file) {
      return file && (file.type.startsWith('audio/') || AUDIO_FILE_REGEX.test(file.name));
    }
    
    function makeTrackId(file) {
      return `${file.name}::${file.size}::${file.lastModified}`;
    }
    
    function trackNameFromFile(file) {
      return file.name.replace(/\.[^.]+$/, '');
    }
    
    function makeTrackIdFromUrl(url) {
      return `url::${url}`;
    }
    
    function trackNameFromUrl(url) {
      try {
        const parsed = new URL(url, window.location.href);
        const pathname = parsed.pathname;
        const filename = pathname.split('/').pop() || 'Track';
        return decodeURIComponent(filename).replace(/\.[^.]+$/, '');
      } catch (err) {
        const fallback = url.split('/').pop() || 'Track';
        return fallback.replace(/\.[^.]+$/, '');
      }
    }
    
    function getExtension(input) {
      const match = /\\.([a-z0-9]+)$/i.exec(input || '');
      return match ? match[1].toLowerCase() : '';
    }
    
    function buildTrackFromFile(file) {
      return {
        id: makeTrackId(file),
        name: trackNameFromFile(file),
        url: URL.createObjectURL(file),
        file,
        isObjectUrl: true,
        duration: NaN,
        extension: getExtension(file.name)
      };
    }
    
    function buildTrackFromUrl(url) {
      return {
        id: makeTrackIdFromUrl(url),
        name: trackNameFromUrl(url),
        url,
        isObjectUrl: false,
        duration: NaN,
        extension: getExtension(url)
      };
    }
    
    function openHandleDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(HANDLE_DB_NAME, 1);
        request.onupgradeneeded = () => {
          request.result.createObjectStore(HANDLE_DB_STORE);
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }
    
    async function saveDirectoryHandle(handle) {
      try {
        const db = await openHandleDB();
        await new Promise((resolve, reject) => {
          const tx = db.transaction(HANDLE_DB_STORE, 'readwrite');
          tx.objectStore(HANDLE_DB_STORE).put(handle, 'musicDir');
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
      } catch (err) {
        console.warn('Could not store directory handle', err);
      }
    }
    
    async function loadDirectoryHandle() {
      try {
        const db = await openHandleDB();
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(HANDLE_DB_STORE, 'readonly');
          const request = tx.objectStore(HANDLE_DB_STORE).get('musicDir');
          request.onsuccess = () => resolve(request.result || null);
          request.onerror = () => reject(request.error);
        });
      } catch (err) {
        console.warn('Could not load directory handle', err);
        return null;
      }
    }
    
    function setPlaylistMeta(text) {
      const meta = document.getElementById('playlistMeta');
      if (!meta) return;
      meta.textContent = text ? `Source: ${text}` : 'Source: None';
    }
    
    function syncCurrentTrackIndex() {
      if (!currentTrackId) {
        currentTrackIndex = tracks.length ? 0 : -1;
        return;
      }
      currentTrackIndex = tracks.findIndex(t => t.id === currentTrackId);
    }
    
    function formatDuration(totalSeconds) {
      if (!isFinite(totalSeconds)) return '--:--';
      const seconds = Math.max(0, Math.floor(totalSeconds));
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    function updatePlaylistStats() {
      const playlistTimeEl = document.getElementById('playlistTime');
      if (!playlistTimeEl) return;
      if (!tracks.length) {
        playlistLoopCount = 0;
        totalPlaylistSeconds = 0;
        playlistTimeEl.textContent = 'Playlist: --:-- ¬∑ Loop: 0';
        return;
      }
      
      const durations = tracks.map(t => (isFinite(t.duration) ? t.duration : 0));
      const unknownCount = tracks.filter(t => !isFinite(t.duration)).length;
      totalPlaylistSeconds = durations.reduce((sum, val) => sum + val, 0);
      const totalLabel = formatDuration(totalPlaylistSeconds) + (unknownCount ? ' +' : '');
      const loopLabel = playlistLoopCount > 0 ? playlistLoopCount : 1;
      playlistTimeEl.textContent = `Playlist: ${totalLabel} ¬∑ Loop: ${loopLabel}`;
    }
    
    function loadTrackDuration(track) {
      return new Promise(resolve => {
        if (!track || !track.url) return resolve();
        const probe = new Audio();
        probe.preload = 'metadata';
        probe.src = track.url;
        const cleanup = () => {
          probe.removeAttribute('src');
          probe.load();
        };
        probe.addEventListener('loadedmetadata', () => {
          track.duration = probe.duration;
          cleanup();
          resolve();
        }, { once: true });
        probe.addEventListener('error', () => {
          track.duration = 0;
          cleanup();
          resolve();
        }, { once: true });
      });
    }
    
    async function refreshPlaylistDurations() {
      if (!tracks.length) {
        updatePlaylistStats();
        return;
      }
      const scanId = ++durationScanId;
      updatePlaylistStats();
      for (const track of tracks) {
        if (scanId !== durationScanId) return;
        if (isFinite(track.duration)) continue;
        await loadTrackDuration(track);
        updatePlaylistStats();
      }
    }
    
    function getColor(i, total, intensity = 1) {
      const colors = colorSchemes[currentColorIndex].colors;
      const idx = Math.floor((i / total) * colors.length) % colors.length;
      return colors[idx];
    }
    
    function getColorRaw(index) {
      return colorSchemes[currentColorIndex].colors[index % colorSchemes[currentColorIndex].colors.length];
    }
    
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 255, g: 255, b: 255 };
    }
    
    function getAvgFrequency(start = 0, end = bufferLength) {
      let sum = 0;
      for (let i = start; i < end; i++) sum += dataArray[i];
      return sum / (end - start);
    }
    
    function getBass() { return getAvgFrequency(0, 10) || 0; }
    function getMid() { return getAvgFrequency(10, 100) || 0; }
    function getTreble() { return getAvgFrequency(100, bufferLength) || 0; }
    
    // Safe radius for canvas arc (prevents IndexSizeError)
    function safeRadius(r) { return Math.max(0.1, r) || 0.1; }
    
    // ==================== SPECTRUM BARS ====================
    function drawSpectrum() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.fillRect(0, 0, w, h);
      
      const bars = 128;
      const barW = w / bars;
      const bass = getBass();
      
      for (let i = 0; i < bars; i++) {
        const idx = Math.floor(i * bufferLength / bars);
        const val = dataArray[idx];
        const barH = (val / 255) * h * 0.85;
        
        const gradient = ctx.createLinearGradient(0, h, 0, h - barH);
        gradient.addColorStop(0, getColor(i, bars));
        gradient.addColorStop(0.5, getColor(i + bars/4, bars));
        gradient.addColorStop(1, getColor(i + bars/2, bars));
        
        ctx.fillStyle = gradient;
        ctx.shadowColor = getColor(i, bars);
        ctx.shadowBlur = bass > 200 ? 30 : 10;
        
        const x = i * barW;
        ctx.fillRect(x + 1, h - barH, barW - 2, barH);
        
        // Mirror reflection
        ctx.globalAlpha = 0.3;
        ctx.fillRect(x + 1, h, barW - 2, barH * 0.3);
        ctx.globalAlpha = 1;
      }
      ctx.shadowBlur = 0;
    }
    
    // ==================== CIRCULAR ====================
    function drawCircular() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      const cx = w / 2, cy = h / 2;
      const radius = Math.min(w, h) * 0.2;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, w, h);
      
      const slices = 180;
      const bass = getBass();
      
      // Outer ring
      for (let i = 0; i < slices; i++) {
        const idx = Math.floor(i * bufferLength / slices);
        const val = dataArray[idx];
        const barH = (val / 255) * radius * 2;
        
        const angle = (i / slices) * Math.PI * 2 - Math.PI / 2;
        const innerR = radius + (bass / 255) * 20;
        const x1 = cx + Math.cos(angle) * innerR;
        const y1 = cy + Math.sin(angle) * innerR;
        const x2 = cx + Math.cos(angle) * (innerR + barH);
        const y2 = cy + Math.sin(angle) * (innerR + barH);
        
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = getColor(i, slices);
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.shadowColor = getColor(i, slices);
        ctx.shadowBlur = 15;
        ctx.stroke();
      }
      
      // Inner pulsing circle
      const pulse = 1 + (bass / 255) * 0.3;
      const pulseRadius = safeRadius(radius * pulse);
      const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, pulseRadius);
      gradient.addColorStop(0, getColorRaw(0));
      gradient.addColorStop(0.5, 'transparent');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, pulseRadius, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
    }
    
    // ==================== PARTICLES ====================
    function drawParticles() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
      ctx.fillRect(0, 0, w, h);
      
      const bass = getBass();
      const mid = getMid();
      
      // Spawn particles on beat
      if (bass > 180 && particles.length < 800) {
        const count = Math.floor(bass / 30);
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 8;
          particles.push({
            x: w / 2,
            y: h / 2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            size: 2 + Math.random() * 6,
            color: getColorRaw(Math.floor(Math.random() * 5)),
            trail: []
          });
        }
      }
      
      // Update and draw
      particles = particles.filter(p => {
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 10) p.trail.shift();
        
        p.x += p.vx * (1 + mid / 200);
        p.y += p.vy * (1 + mid / 200);
        p.life -= 0.008;
        
        // Draw trail
        ctx.beginPath();
        p.trail.forEach((pt, i) => {
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.lineTo(p.x, p.y);
        ctx.strokeStyle = p.color;
        ctx.globalAlpha = p.life * 0.5;
        ctx.lineWidth = p.size * 0.5;
        ctx.stroke();
        
        // Draw head
        ctx.beginPath();
        ctx.arc(p.x, p.y, safeRadius(p.size * p.life), 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 20;
        ctx.fill();
        
        ctx.globalAlpha = 1;
        return p.life > 0;
      });
      
      ctx.shadowBlur = 0;
    }
    
    // ==================== DNA HELIX ====================
    function drawDNA() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.12)';
      ctx.fillRect(0, 0, w, h);
      
      const bass = getBass();
      time += 0.03;
      
      const strands = 60;
      const amplitude = 150 + bass * 0.5;
      
      for (let i = 0; i < strands; i++) {
        const idx = Math.floor(i * bufferLength / strands);
        const val = dataArray[idx];
        const progress = i / strands;
        const y = progress * h;
        
        const phase1 = time + progress * 8;
        const phase2 = time + progress * 8 + Math.PI;
        
        const x1 = w / 2 + Math.sin(phase1) * amplitude;
        const x2 = w / 2 + Math.sin(phase2) * amplitude;
        
        const size = 5 + (val / 255) * 15;
        
        // Connecting bar
        ctx.beginPath();
        ctx.moveTo(x1, y);
        ctx.lineTo(x2, y);
        ctx.strokeStyle = `rgba(255,255,255,${0.1 + val/500})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Strand 1
        ctx.beginPath();
        ctx.arc(x1, y, safeRadius(size), 0, Math.PI * 2);
        ctx.fillStyle = getColor(i, strands);
        ctx.shadowColor = getColor(i, strands);
        ctx.shadowBlur = 20;
        ctx.fill();
        
        // Strand 2
        ctx.beginPath();
        ctx.arc(x2, y, safeRadius(size), 0, Math.PI * 2);
        ctx.fillStyle = getColor(i + strands/2, strands);
        ctx.shadowColor = getColor(i + strands/2, strands);
        ctx.fill();
      }
      
      ctx.shadowBlur = 0;
    }
    
    // ==================== KALEIDOSCOPE ====================
    function drawKaleidoscope() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      const cx = w / 2, cy = h / 2;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, w, h);
      
      time += 0.02;
      const segments = 12;
      const bass = getBass();
      
      ctx.save();
      ctx.translate(cx, cy);
      
      for (let seg = 0; seg < segments; seg++) {
        ctx.save();
        ctx.rotate((seg / segments) * Math.PI * 2);
        
        if (seg % 2 === 1) ctx.scale(1, -1);
        
        for (let i = 0; i < 30; i++) {
          const idx = Math.floor(i * bufferLength / 30);
          const val = dataArray[idx];
          const dist = 50 + i * 15 + (val / 255) * 50;
          const angle = time + i * 0.2;
          
          const x = Math.cos(angle) * dist;
          const y = Math.sin(angle) * dist * 0.5;
          const size = 3 + (val / 255) * 12;
          
          ctx.beginPath();
          ctx.arc(x, y, safeRadius(size), 0, Math.PI * 2);
          ctx.fillStyle = getColor(i + seg, 30);
          ctx.shadowColor = getColor(i + seg, 30);
          ctx.shadowBlur = bass > 180 ? 30 : 10;
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      ctx.restore();
      ctx.shadowBlur = 0;
    }
    
    // ==================== MATRIX ====================
    let matrixDrops = [];
    function drawMatrix() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, w, h);
      
      const bass = getBass();
      const chars = 'ÔΩ±ÔΩ≤ÔΩ≥ÔΩ¥ÔΩµÔΩ∂ÔΩ∑ÔΩ∏ÔΩπÔΩ∫ÔΩªÔΩºÔΩΩÔΩæÔΩøÔæÄÔæÅÔæÇÔæÉÔæÑÔæÖÔæÜÔæáÔæàÔæâÔæäÔæãÔæåÔæçÔæéÔæèÔæêÔæëÔæíÔæìÔæîÔæïÔæñÔæóÔæòÔæôÔæöÔæõÔæúÔæù01234567890';
      const fontSize = 16;
      const cols = Math.floor(w / fontSize);
      
      if (matrixDrops.length !== cols) {
        matrixDrops = Array(cols).fill(0).map(() => Math.random() * -100);
      }
      
      ctx.font = fontSize + 'px monospace';
      
      for (let i = 0; i < cols; i++) {
        const idx = Math.floor(i * bufferLength / cols);
        const val = dataArray[idx];
        const char = chars[Math.floor(Math.random() * chars.length)];
        const x = i * fontSize;
        const y = matrixDrops[i] * fontSize;
        
        // Head character (bright)
        ctx.fillStyle = getColorRaw(0);
        ctx.shadowColor = getColorRaw(0);
        ctx.shadowBlur = 20;
        ctx.fillText(char, x, y);
        
        // Trail
        for (let j = 1; j < 20; j++) {
          const trailY = y - j * fontSize;
          if (trailY > 0) {
            const alpha = 1 - j / 20;
            const rgb = hexToRgb(getColorRaw(1));
            ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha * 0.5})`;
            ctx.shadowBlur = 0;
            ctx.fillText(chars[Math.floor(Math.random() * chars.length)], x, trailY);
          }
        }
        
        matrixDrops[i] += 0.3 + (val / 255) * 0.7 + (bass > 200 ? 1 : 0);
        
        if (matrixDrops[i] * fontSize > h && Math.random() > 0.95) {
          matrixDrops[i] = 0;
        }
      }
      
      ctx.shadowBlur = 0;
    }
    
    // ==================== FIREWORKS ====================
    let fireworks = [];
    let fwParticles = [];
    function drawFireworks() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.fillRect(0, 0, w, h);
      
      const bass = getBass() || 0;
      
      // Hard cap on particles to prevent memory issues
      const MAX_PARTICLES = 300;
      const MAX_FIREWORKS = 4;
      
      // Launch new firework on bass hit (or randomly when quiet)
      const shouldLaunch = (bass > 180 && Math.random() > 0.8) || Math.random() > 0.995;
      if (shouldLaunch && fireworks.length < MAX_FIREWORKS && fwParticles.length < MAX_PARTICLES) {
        fireworks.push({
          x: Math.random() * w,
          y: h,
          vy: -12 - Math.random() * 4,
          targetY: 100 + Math.random() * (h * 0.35),
          color: getColorRaw(Math.floor(Math.random() * 5))
        });
      }
      
      // Draw rising fireworks
      const newFireworks = [];
      for (let i = 0; i < fireworks.length; i++) {
        const fw = fireworks[i];
        fw.y += fw.vy;
        fw.vy += 0.25;
        
        // Draw rocket
        ctx.beginPath();
        ctx.arc(fw.x, fw.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = fw.color;
        ctx.fill();
        
        // Explode when reaching target or falling
        if (fw.y <= fw.targetY || fw.vy >= 0) {
          // Create explosion particles (capped)
          const count = Math.min(40, MAX_PARTICLES - fwParticles.length);
          for (let j = 0; j < count; j++) {
            const angle = (j / count) * Math.PI * 2;
            const speed = 2 + Math.random() * 5;
            fwParticles.push({
              x: fw.x,
              y: fw.y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 1,
              color: Math.random() > 0.3 ? fw.color : getColorRaw(Math.floor(Math.random() * 5)),
              size: 2 + Math.random() * 2
            });
          }
        } else {
          newFireworks.push(fw);
        }
      }
      fireworks = newFireworks;
      
      // Update and draw particles
      const newParticles = [];
      for (let i = 0; i < fwParticles.length; i++) {
        const p = fwParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.12;
        p.vx *= 0.98;
        p.life -= 0.02;
        
        if (p.life > 0.01) {
          ctx.globalAlpha = Math.max(0, p.life) || 0;
          ctx.beginPath();
          ctx.arc(p.x, p.y, safeRadius(p.size * p.life), 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
          newParticles.push(p);
        }
      }
      fwParticles = newParticles;
      
      // Reset canvas state
      ctx.globalAlpha = 1;
    }
    
    // ==================== AURORA ====================
    function drawAurora() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      ctx.fillStyle = 'rgba(0, 0, 10, 0.1)';
      ctx.fillRect(0, 0, w, h);
      
      time += 0.01;
      const bass = getBass();
      const layers = 5;
      
      for (let layer = 0; layer < layers; layer++) {
        ctx.beginPath();
        ctx.moveTo(0, h);
        
        const baseY = h * 0.3 + layer * 60;
        const points = 100;
        
        for (let i = 0; i <= points; i++) {
          const x = (i / points) * w;
          const idx = Math.floor(i * bufferLength / points);
          const val = dataArray[idx];
          
          const wave1 = Math.sin(time * 2 + i * 0.05 + layer) * 50;
          const wave2 = Math.sin(time * 3 + i * 0.08) * 30;
          const audioWave = (val / 255) * 100;
          
          const y = baseY + wave1 + wave2 - audioWave;
          
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        
        const gradient = ctx.createLinearGradient(0, baseY - 100, 0, h);
        const rgb = hexToRgb(getColor(layer, layers));
        gradient.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.4 + bass/500})`);
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.fill();
      }
      
      // Stars
      if (Math.random() > 0.9) {
        ctx.beginPath();
        ctx.arc(Math.random() * w, Math.random() * h * 0.5, 1, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }
    }
    
    // ==================== SYNTHWAVE ====================
    function drawSynthwave() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      // Sky gradient
      const skyGradient = ctx.createLinearGradient(0, 0, 0, h);
      skyGradient.addColorStop(0, '#0a0a20');
      skyGradient.addColorStop(0.5, '#1a0a30');
      skyGradient.addColorStop(1, '#000');
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, w, h);
      
      time += 0.02;
      const bass = getBass();
      const horizon = h * 0.5;
      
      // Sun
      const sunY = horizon - 80 - (bass / 255) * 30;
      const sunRadius = safeRadius(120 + bass * 0.2);
      const sunGradient = ctx.createRadialGradient(w/2, sunY, 0, w/2, sunY, sunRadius);
      sunGradient.addColorStop(0, getColorRaw(0));
      sunGradient.addColorStop(0.5, getColorRaw(1));
      sunGradient.addColorStop(1, 'transparent');
      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(w/2, sunY, sunRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Sun lines
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, sunY, w, h);
      ctx.clip();
      for (let i = 0; i < 8; i++) {
        const lineY = sunY + 20 + i * 15;
        ctx.fillStyle = '#0a0a20';
        ctx.fillRect(w/2 - 150, lineY, 300, 8 + i * 2);
      }
      ctx.restore();
      
      // Grid floor
      ctx.strokeStyle = getColorRaw(2);
      ctx.lineWidth = 1;
      ctx.shadowColor = getColorRaw(2);
      ctx.shadowBlur = 10;
      
      // Horizontal lines
      for (let i = 0; i < 20; i++) {
        const y = horizon + Math.pow(i / 20, 2) * (h - horizon);
        const alpha = 1 - i / 25;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
      
      // Vertical lines
      const vLines = 30;
      for (let i = -vLines/2; i <= vLines/2; i++) {
        const xBottom = w/2 + i * 100;
        const xTop = w/2 + i * 10;
        ctx.globalAlpha = 1 - Math.abs(i) / (vLines/2) * 0.5;
        ctx.beginPath();
        ctx.moveTo(xTop, horizon);
        ctx.lineTo(xBottom, h);
        ctx.stroke();
      }
      
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      
      // Spectrum bars in front
      const bars = 64;
      const barW = w / bars;
      for (let i = 0; i < bars; i++) {
        const idx = Math.floor(i * bufferLength / bars);
        const val = dataArray[idx];
        const barH = (val / 255) * 150;
        
        ctx.fillStyle = getColor(i, bars);
        ctx.shadowColor = getColor(i, bars);
        ctx.shadowBlur = 15;
        ctx.fillRect(i * barW + 2, h - barH, barW - 4, barH);
      }
      
      ctx.shadowBlur = 0;
    }
    
    // ==================== FRACTAL ====================
    function drawFractal() {
      analyser.getByteFrequencyData(dataArray);
      const w = window.innerWidth, h = window.innerHeight;
      
      // Solid black background (no fade - we redraw everything each frame)
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      
      time += 0.015;
      const bass = getBass() || 100; // Default value when no audio
      const mid = getMid() || 80;
      
      const branches = [];
      const MAX_BRANCHES = 200; // Safety cap
      
      function calcBranch(x, y, angle, length, depth, colorIdx) {
        if (depth <= 0 || length < 10 || branches.length >= MAX_BRANCHES) return;
        
        const idx = Math.min(Math.floor(depth * bufferLength / 7), bufferLength - 1);
        const val = dataArray[idx] || 128;
        const audioMod = 1 + (val / 255) * 0.3;
        
        const endX = x + Math.cos(angle) * length * audioMod;
        const endY = y + Math.sin(angle) * length * audioMod;
        
        branches.push({
          x1: x, y1: y, x2: endX, y2: endY,
          depth: depth,
          color: getColor(colorIdx + depth, 10)
        });
        
        const spread = 0.45 + (mid / 255) * 0.2;
        const shrink = 0.7;
        
        calcBranch(endX, endY, angle - spread, length * shrink, depth - 1, colorIdx);
        calcBranch(endX, endY, angle + spread, length * shrink, depth - 1, colorIdx);
      }
      
      // Generate trees (3 trees, depth 7)
      const trees = 3;
      for (let t = 0; t < trees; t++) {
        const treeX = w * (t + 1) / (trees + 1);
        const sway = Math.sin(time + t * 2) * 0.12;
        const baseAngle = -Math.PI / 2 + sway;
        const baseLength = 90 + (bass / 255) * 40;
        calcBranch(treeX, h, baseAngle, baseLength, 7, t * 3);
      }
      
      // Render all branches (thick first for proper layering)
      branches.sort((a, b) => b.depth - a.depth);
      
      // Draw glow pass for main branches only
      ctx.shadowBlur = 12;
      for (let i = 0; i < branches.length; i++) {
        const b = branches[i];
        if (b.depth >= 5) {
          ctx.beginPath();
          ctx.moveTo(b.x1, b.y1);
          ctx.lineTo(b.x2, b.y2);
          ctx.strokeStyle = b.color;
          ctx.shadowColor = b.color;
          ctx.lineWidth = b.depth * 1.2;
          ctx.lineCap = 'round';
          ctx.stroke();
        }
      }
      ctx.shadowBlur = 0;
      
      // Draw all branches (no glow)
      for (let i = 0; i < branches.length; i++) {
        const b = branches[i];
        ctx.beginPath();
        ctx.moveTo(b.x1, b.y1);
        ctx.lineTo(b.x2, b.y2);
        ctx.strokeStyle = b.color;
        ctx.lineWidth = Math.max(1, b.depth * 0.9);
        ctx.lineCap = 'round';
        ctx.stroke();
      }
    }
    
    // ==================== UI SETUP ====================
    function resize() {
      const ratio = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * ratio;
      canvas.height = window.innerHeight * ratio;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(ratio, ratio);
    }
    window.addEventListener('resize', resize);
    resize();
    
    // Build viz buttons
    const vizModes = document.getElementById('vizModes');
    visualizations.forEach((viz, i) => {
      const btn = document.createElement('button');
      btn.className = 'viz-btn' + (i === 0 ? ' active' : '');
      btn.innerHTML = `<span class="key">${viz.key}</span>${viz.name}`;
      btn.dataset.index = i;
      btn.onclick = () => setVisualization(i);
      vizModes.appendChild(btn);
    });
    
    function setVisualization(index) {
      currentVizIndex = index;
      document.querySelectorAll('.viz-btn').forEach((b, i) => {
        b.classList.toggle('active', i === index);
      });
      showModeDisplay(visualizations[index].name);
      // Reset mode-specific state
      particles = [];
      fireworks = [];
      fwParticles = [];
      matrixDrops = [];
      // Reset canvas state
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    
    function setColorScheme(index) {
      currentColorIndex = index;
      document.getElementById('colorName').textContent = colorSchemes[index].name;
      showModeDisplay(colorSchemes[index].name, colorSchemes[index].colors[0]);
    }
    
    function showModeDisplay(text, color = null) {
      const display = document.getElementById('modeDisplay');
      display.textContent = text;
      display.style.color = color || getColorRaw(0);
      display.classList.add('show');
      setTimeout(() => display.classList.remove('show'), 800);
    }
    
    function toggleHelp(show = null) {
      const overlay = document.getElementById('helpOverlay');
      if (!overlay) return;
      if (show === null) {
        overlay.classList.toggle('show');
      } else {
        overlay.classList.toggle('show', show);
      }
    }
    
    // ==================== AUDIO ====================
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 512;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        timeArray = new Uint8Array(bufferLength);
        analyserConnected = false;
      }
      if (!analyserConnected) {
        analyser.connect(audioContext.destination);
        analyserConnected = true;
      }
    }
    
    function showToast(msg, type = 'error') {
      const toast = document.getElementById('errorToast');
      toast.textContent = msg;
      toast.classList.remove('info', 'warn');
      if (type === 'info') toast.classList.add('info');
      if (type === 'warn') toast.classList.add('warn');
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 5000);
    }
    
    function showError(msg) {
      showToast(msg, 'error');
    }
    
    function showInfo(msg) {
      showToast(msg, 'info');
    }
    
    function showWarn(msg) {
      showToast(msg, 'warn');
    }
    
    function describeAudioError(track, error) {
      const code = error ? error.code : null;
      const ext = track && track.extension ? track.extension : '';
      const base = track ? `"${track.name}"` : 'This track';
      switch (code) {
        case 1:
          return `${base} playback was aborted.`;
        case 2:
          return `${base} could not be loaded (network or file error).`;
        case 3:
          return `${base} could not be decoded. Try Safari for AIFF or convert to WAV/MP3.`;
        case 4:
          return `${base} is not supported in this browser.`;
        default:
          if (ext === 'aif' || ext === 'aiff') {
            return `${base} is AIFF. Use Safari or convert to WAV/MP3.`;
          }
          return `${base} could not be played.`;
      }
    }
    
    function loadTrack(index) {
      if (tracks.length === 0) return;
      
      currentTrackIndex = index;
      const track = tracks[index];
      currentTrackId = track.id;
      
      if (audio) {
        audio.pause();
        if (source) source.disconnect();
      }
      
      audio = new Audio();
      audio.src = track.url;
      
      showInfo(`Loading: ${track.name}`);
      audio.addEventListener('error', () => {
        showError(describeAudioError(track, audio.error));
      });
      audio.addEventListener('canplay', () => {
        showInfo(`Ready: ${track.name}`);
      }, { once: true });
      
      initAudio();
      source = audioContext.createMediaElementSource(audio);
      source.connect(analyser);
      
      document.getElementById('trackName').textContent = track.name;
      document.getElementById('dropZone').classList.add('has-audio');
      
      audio.addEventListener('timeupdate', updateProgress);
      audio.addEventListener('ended', () => {
        if (!tracks.length) {
          pause();
          return;
        }
        playNextTrack({ auto: true });
      });
      
      updatePlaylist();
    }
    
    function updatePlayIcon(playing) {
      document.getElementById('playIcon').innerHTML = playing
        ? '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>'
        : '<polygon points="5,3 19,12 5,21"/>';
    }
    
    function play() {
      if (!audio) {
        showWarn('No track loaded. Choose a folder first.');
        return;
      }
      initAudio();
      const resumePromise = audioContext.resume();
      if (resumePromise && resumePromise.catch) {
        resumePromise.catch(() => {
          showWarn('Audio context is blocked. Click the page to enable sound.');
        });
      }
      
      const playPromise = audio.play();
      if (playPromise && playPromise.then) {
        playPromise.then(() => {
          isPlaying = true;
          updatePlayIcon(true);
        }).catch(err => {
          isPlaying = false;
          updatePlayIcon(false);
          if (err && err.name === 'NotAllowedError') {
            showWarn('Playback blocked. Click anywhere or press Space to start.');
          } else {
            showError('Playback failed. Try another track or browser.');
          }
        });
      } else {
        isPlaying = true;
        updatePlayIcon(true);
      }
    }
    
    function pause() {
      if (!audio) return;
      audio.pause();
      isPlaying = false;
      updatePlayIcon(false);
    }
    
    function playNextTrack(options = {}) {
      if (!tracks.length) return;
      const auto = options.auto === true;
      const nextIndex = currentTrackIndex === -1 ? 0 : currentTrackIndex + 1;
      if (nextIndex < tracks.length) {
        loadTrack(nextIndex);
        play();
        return;
      }
      if (loopAll) {
        playlistLoopCount = Math.max(1, playlistLoopCount);
        if (auto) playlistLoopCount += 1;
        loadTrack(0);
        play();
        updatePlaylistStats();
      } else {
        pause();
      }
    }
    
    function playPreviousTrack() {
      if (!tracks.length) return;
      const prevIndex = currentTrackIndex === -1 ? 0 : currentTrackIndex - 1;
      if (prevIndex >= 0) {
        loadTrack(prevIndex);
        play();
        return;
      }
      if (loopAll) {
        loadTrack(tracks.length - 1);
        play();
      }
    }
    
    function updateProgress() {
      if (!audio) return;
      const duration = audio.duration;
      const progress = duration && isFinite(duration) ? (audio.currentTime / duration) * 100 : 0;
      document.getElementById('progressFill').style.width = progress + '%';
      document.getElementById('trackTime').textContent = 
        formatTime(audio.currentTime) + ' / ' + formatTime(duration);
    }
    
    function formatTime(s) {
      if (isNaN(s)) return '0:00';
      return Math.floor(s / 60) + ':' + Math.floor(s % 60).toString().padStart(2, '0');
    }
    
    function updatePlaylist() {
      const container = document.getElementById('playlistItems');
      container.innerHTML = '';
      tracks.forEach((track, i) => {
        const item = document.createElement('div');
        item.className = 'playlist-item' + (i === currentTrackIndex ? ' active' : '');
        item.textContent = track.name;
        item.onclick = () => { loadTrack(i); play(); };
        container.appendChild(item);
      });
      updatePlaylistStats();
    }
    
    function appendTracksFromFiles(files, sourceLabel = 'Files') {
      const audioFiles = Array.from(files).filter(isAudioFile);
      if (audioFiles.length === 0) {
        showWarn('No audio files found.');
        return;
      }
      
      const existingIds = new Set(tracks.map(t => t.id));
      audioFiles.forEach(file => {
        const track = buildTrackFromFile(file);
        if (existingIds.has(track.id)) return;
        tracks.push(track);
        existingIds.add(track.id);
      });
      
      if (tracks.length > 0) {
        document.getElementById('playlist').classList.remove('hidden');
        syncCurrentTrackIndex();
        updatePlaylist();
        if (!audio) loadTrack(0);
      }
      showInfo(`Added ${audioFiles.length} track${audioFiles.length === 1 ? '' : 's'}.`);
      
      if (playlistLoopCount === 0 && tracks.length) {
        playlistLoopCount = 1;
      }
      refreshPlaylistDurations();
      
      const metaLabel = lastFolderLabel ? `${lastFolderLabel} + ${sourceLabel}` : sourceLabel;
      setPlaylistMeta(metaLabel);
    }
    
    function replaceTracksFromFiles(files, sourceLabel = 'Folder') {
      const audioFiles = Array.from(files).filter(isAudioFile);
      if (audioFiles.length === 0) {
        showWarn('No audio files found in this folder.');
        return;
      }
      
      audioFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
      const oldById = new Map(tracks.map(t => [t.id, t]));
      const nextTracks = [];
      
      audioFiles.forEach(file => {
        const id = makeTrackId(file);
        const existing = oldById.get(id);
        if (existing) {
          existing.file = file;
          nextTracks.push(existing);
        } else {
          nextTracks.push(buildTrackFromFile(file));
        }
      });
      
      const nextIds = new Set(nextTracks.map(t => t.id));
      tracks.forEach(t => {
        if (!nextIds.has(t.id) && t.isObjectUrl) URL.revokeObjectURL(t.url);
      });
      
      const wasPlaying = isPlaying;
      tracks = nextTracks;
      syncCurrentTrackIndex();
      document.getElementById('playlist').classList.remove('hidden');
      updatePlaylist();
      if (!audio && tracks.length) {
        loadTrack(0);
      } else if (wasPlaying && currentTrackIndex === -1 && tracks.length) {
        loadTrack(0);
        play();
      }
      if (tracks.length) {
        playlistLoopCount = 1;
      } else {
        playlistLoopCount = 0;
      }
      refreshPlaylistDurations();
      
      lastFolderLabel = sourceLabel;
      setPlaylistMeta(sourceLabel);
      showInfo(`Loaded ${tracks.length} track${tracks.length === 1 ? '' : 's'} from ${sourceLabel}.`);
    }
    
    function replaceTracksFromUrls(urls, sourceLabel = 'Current Folder') {
      if (!urls || urls.length === 0) {
        showWarn('No audio files found in this folder.');
        return false;
      }
      
      const unique = Array.from(new Set(urls));
      const oldById = new Map(tracks.map(t => [t.id, t]));
      const nextTracks = unique.map(url => {
        const id = makeTrackIdFromUrl(url);
        const existing = oldById.get(id);
        if (existing) return existing;
        return buildTrackFromUrl(url);
      });
      
      const nextIds = new Set(nextTracks.map(t => t.id));
      tracks.forEach(t => {
        if (!nextIds.has(t.id) && t.isObjectUrl) URL.revokeObjectURL(t.url);
      });
      
      const wasPlaying = isPlaying;
      tracks = nextTracks;
      syncCurrentTrackIndex();
      document.getElementById('playlist').classList.remove('hidden');
      updatePlaylist();
      
      if (!audio && tracks.length) {
        loadTrack(0);
      } else if (wasPlaying && currentTrackIndex === -1 && tracks.length) {
        loadTrack(0);
        play();
      }
      
      if (tracks.length) {
        playlistLoopCount = 1;
      } else {
        playlistLoopCount = 0;
      }
      refreshPlaylistDurations();
      
      lastFolderLabel = sourceLabel;
      setPlaylistMeta(sourceLabel);
      showInfo(`Loaded ${tracks.length} track${tracks.length === 1 ? '' : 's'} from ${sourceLabel}.`);
      return true;
    }
    
    function getFolderLabelFromFiles(files) {
      const first = files && files[0];
      if (!first || !first.webkitRelativePath) return 'Folder';
      const parts = first.webkitRelativePath.split('/');
      return parts[0] || 'Folder';
    }
    
    function getCurrentFolderLabel() {
      const path = decodeURIComponent(window.location.pathname || '');
      const parts = path.split('/').filter(Boolean);
      if (parts.length === 0) return 'Current Folder';
      const last = parts[parts.length - 1];
      if (last.includes('.')) {
        return parts[parts.length - 2] || 'Current Folder';
      }
      return last || 'Current Folder';
    }
    
    function extractAudioUrlsFromListing(html, baseUrl) {
      const links = new Set();
      const hrefRegex = /href\s*=\s*["']([^"']+)["']/gi;
      let match;
      while ((match = hrefRegex.exec(html))) {
        const href = match[1];
        if (!href || href.startsWith('?') || href.startsWith('#')) continue;
        if (href.toLowerCase().startsWith('javascript:')) continue;
        let url;
        try {
          url = new URL(href, baseUrl);
        } catch (err) {
          continue;
        }
        if (url.pathname.endsWith('/')) continue;
        if (!AUDIO_FILE_REGEX.test(url.pathname)) continue;
        links.add(url.href);
      }
      return Array.from(links);
    }
    
    async function autoDetectFromDirectoryListing() {
      if (window.location.protocol === 'file:') {
        showInfo('Auto-detect is blocked on file://. Press O to choose a folder.');
        return false;
      }
      const baseUrl = window.location.href.replace(/[#?].*$/, '');
      try {
        const response = await fetch('./', { cache: 'no-store' });
        if (!response.ok) return false;
        const text = await response.text();
        const urls = extractAudioUrlsFromListing(text, baseUrl);
        if (!urls.length) {
          showWarn('No audio files found in directory listing.');
          return false;
        }
        const label = getCurrentFolderLabel();
        return replaceTracksFromUrls(urls, label);
      } catch (err) {
        showWarn('Could not read the directory listing. Use O to choose a folder.');
        return false;
      }
    }
    
    async function scanDirectoryHandle(handle) {
      const files = [];
      for await (const [name, entry] of handle.entries()) {
        if (entry.kind !== 'file') continue;
        if (!AUDIO_FILE_REGEX.test(name)) continue;
        const file = await entry.getFile();
        files.push(file);
      }
      
      if (files.length === 0) {
        showWarn('No audio files found in this folder.');
        return;
      }
      
      replaceTracksFromFiles(files, handle.name || 'Folder');
    }
    
    async function chooseFolder() {
      if (supportsDirectoryPicker) {
        try {
          const handle = await window.showDirectoryPicker({ mode: 'read' });
          directoryHandle = handle;
          await saveDirectoryHandle(handle);
          await scanDirectoryHandle(handle);
        } catch (err) {
          if (err && err.name !== 'AbortError') {
            showError('Could not access that folder.');
          }
        }
      } else if (supportsDirInput) {
        document.getElementById('dirInput').click();
      } else {
        document.getElementById('fileInput').click();
        showError('Folder picking not supported in this browser. Select files instead.');
      }
    }
    
    async function rescanLibrary() {
      if (directoryHandle) {
        try {
          const perm = await directoryHandle.queryPermission({ mode: 'read' });
          if (perm !== 'granted') {
            const req = await directoryHandle.requestPermission({ mode: 'read' });
            if (req !== 'granted') {
              showError('Folder permission not granted.');
              return;
            }
          }
          await scanDirectoryHandle(directoryHandle);
        } catch (err) {
          showError('Could not rescan the folder.');
        }
        return;
      }
      
      const autoFound = await autoDetectFromDirectoryListing();
      if (!autoFound) {
        await chooseFolder();
      }
    }
    
    // ==================== EVENT HANDLERS ====================
    document.body.addEventListener('dragover', e => e.preventDefault());
    document.body.addEventListener('drop', e => {
      e.preventDefault();
      appendTracksFromFiles(e.dataTransfer.files, 'Dropped Files');
    });
    
    document.body.addEventListener('click', e => {
      if (!tracks.length && (e.target === document.body || e.target === canvas || 
          e.target.closest('.drop-zone'))) {
        chooseFolder();
      }
    });
    
    document.getElementById('fileInput').addEventListener('change', e => {
      appendTracksFromFiles(e.target.files, 'Files');
      e.target.value = '';
    });
    
    document.getElementById('dirInput').addEventListener('change', e => {
      const label = getFolderLabelFromFiles(e.target.files);
      const files = Array.from(e.target.files);
      const topLevelFiles = files.filter(file => {
        const rel = file.webkitRelativePath || '';
        const depth = rel.split('/').filter(Boolean).length;
        return depth <= 2;
      });
      if (topLevelFiles.length !== files.length) {
        showInfo('Ignoring subfolders. Only top-level files are loaded.');
      }
      replaceTracksFromFiles(topLevelFiles, label);
      e.target.value = '';
    });
    
    document.getElementById('playBtn').onclick = () => isPlaying ? pause() : play();
    document.getElementById('folderBtn').onclick = () => chooseFolder();
    document.getElementById('rescanBtn').onclick = () => rescanLibrary();
    document.getElementById('helpBtn').onclick = () => toggleHelp();
    document.getElementById('helpClose').onclick = () => toggleHelp(false);
    document.getElementById('helpOverlay').addEventListener('click', e => {
      if (e.target.id === 'helpOverlay') toggleHelp(false);
    });
    
    document.getElementById('progressBar').onclick = e => {
      if (!audio || !isFinite(audio.duration)) return;
      const rect = e.currentTarget.getBoundingClientRect();
      audio.currentTime = ((e.clientX - rect.left) / rect.width) * audio.duration;
    };
    
    document.getElementById('fullscreenBtn').onclick = () => {
      document.fullscreenElement ? document.exitFullscreen() : document.body.requestFullscreen();
    };
    
    document.getElementById('colorBtn').onclick = () => {
      setColorScheme((currentColorIndex + 1) % colorSchemes.length);
    };
    
    // Auto-hide controls
    function showControls() {
      document.getElementById('controls').classList.remove('hidden');
      document.getElementById('topActions').classList.remove('hidden');
      document.getElementById('playlist').classList.remove('hidden');
      document.getElementById('shortcutsHint').classList.remove('hidden');
      clearTimeout(hideTimeout);
      hideTimeout = setTimeout(() => {
        if (isPlaying) {
          document.getElementById('controls').classList.add('hidden');
          document.getElementById('topActions').classList.add('hidden');
          document.getElementById('playlist').classList.add('hidden');
          document.getElementById('shortcutsHint').classList.add('hidden');
        }
      }, 3000);
    }
    
    document.addEventListener('mousemove', showControls);
    
    // ==================== KEYBOARD SHORTCUTS ====================
    document.addEventListener('keydown', e => {
      // Number keys for visualizations
      const vizKey = visualizations.findIndex(v => v.key === e.key);
      if (vizKey !== -1) {
        setVisualization(vizKey);
        return;
      }
      
      switch(e.code) {
        case 'Space':
          e.preventDefault();
          isPlaying ? pause() : play();
          break;
        case 'ArrowRight':
          playNextTrack();
          break;
        case 'ArrowLeft':
          playPreviousTrack();
          break;
        case 'KeyF':
          document.getElementById('fullscreenBtn').click();
          break;
        case 'KeyC':
          setColorScheme((currentColorIndex + 1) % colorSchemes.length);
          break;
        case 'KeyO':
          chooseFolder();
          break;
        case 'KeyR':
          rescanLibrary();
          break;
        case 'KeyH':
          toggleHelp();
          break;
        case 'Escape':
          toggleHelp(false);
          break;
      }
    });
    
    // ==================== AUTO-LOAD SAVED FOLDER ====================
    async function autoLoadSavedFolder() {
      let loaded = false;
      if (supportsDirectoryPicker) {
        const handle = await loadDirectoryHandle();
        if (handle) {
          const perm = await handle.queryPermission({ mode: 'read' });
          if (perm === 'granted') {
            directoryHandle = handle;
            await scanDirectoryHandle(handle);
            loaded = true;
          }
        }
      }
      if (!loaded) {
        await autoDetectFromDirectoryListing();
      }
    }
    
    autoLoadSavedFolder();
    
    // ==================== ANIMATION LOOP ====================
    function animate() {
      try {
        if (analyser && dataArray) {
          visualizations[currentVizIndex].fn();
        } else {
          // Clear to black when no audio
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
        }
      } catch (err) {
        console.error('Visualization error:', err);
        // Reset canvas state to prevent corruption
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
      requestAnimationFrame(animate);
    }
    
    animate();
  </script>
</body>
</html>
